

# **Detecting Adversary Techniques in Apache & IIS Logs: A MITRE ATT\&CK-Driven Approach with Splunk**

## **Section 1: Foundations for Web Log Threat Detection**

Effective threat detection within web server logs is not a matter of simply searching for keywords; it is a discipline built upon a foundational understanding of the data source itself. The quality and structure of the logs generated by web servers like Apache and Microsoft Internet Information Services (IIS) directly dictate the potential for successful analysis. Before an analyst can write a single query, they must ensure that the telemetry being collected is comprehensive. Furthermore, to build robust, scalable, and vendor-agnostic detections, this raw telemetry must be normalized into a common schema. This section details the critical log formats for Apache and IIS and explains the indispensable role of the Splunk Common Information Model (CIM) in creating a unified data model for threat hunting.

### **1.1. The Anatomy of a Web Request: Apache and IIS Access Logs**

The access log is the primary record of every interaction a client has with a web server. Understanding its structure is the first step toward extracting security value.

#### **Apache Logs (Common vs. Combined Format)**

The Apache HTTP Server offers several logging formats, controlled by the LogFormat directive in its configuration files.1 While flexible, this can lead to inconsistent or incomplete logging if not managed carefully.

The Common Log Format (CLF) is a historical standard that provides a basic overview of a request. It includes the client IP, timestamp, request line (method, URI, protocol), status code, and response size.2 However, for modern security analysis, the CLF is critically insufficient because it omits two of the most valuable fields for behavioral analysis: the

Referer and the User-Agent.

The Combined Log Format is the de facto standard for security-relevant logging in Apache. It includes all the fields of the CLF and adds the Referer and User-Agent headers.2 The

Referer header indicates the URL from which the request originated, which is crucial for identifying direct, unlinked access common with web shells. The User-Agent string identifies the client software and is a powerful data point for statistical analysis to uncover non-standard tools used by attackers.5 It is imperative that all production Apache servers are configured to use the

Combined Log Format or a custom format that includes, at a minimum, these fields.1

#### **IIS Logs (W3C Extended Format)**

Microsoft IIS primarily uses the W3C Extended log format, which is highly customizable. This allows administrators to select precisely which fields to log, offering a trade-off between log verbosity and storage size.7 From a security perspective, this customizability is a potential pitfall; a minimally configured IIS server may not log the fields necessary for effective threat detection.

To ensure maximum visibility, the following fields must be enabled in the IIS logging configuration for each website:

* **Request Details:** date, time, cs-method, cs-uri-stem, cs-uri-query, cs-version, cs-host  
* **Client Information:** c-ip, cs-username, cs(User-Agent), cs(Referer)  
* **Server Response:** s-sitename, s-ip, s-port, sc-status, sc-win32-status  
* **Performance & Data Volume:** time-taken, sc-bytes, cs-bytes

Enabling this comprehensive set of fields ensures that the logs capture not only the request itself but also the context surrounding it, such as the client's identity, the server's response, and performance metrics that can be used for anomaly detection.8

The quality of the raw telemetry is the bedrock of any log-based detection strategy. A common failure point in security monitoring programs is the discovery, often during an active incident, that critical log fields were never enabled. Advanced behavioral detections for threats like web shells rely heavily on analyzing the Referer (or its absence) and the statistical rarity of the User-Agent.5 If these fields are not being logged at the source, the detection is impossible. Therefore, the first and most critical step for any organization is to audit and enforce a comprehensive logging policy on all public-facing web servers

*before* implementing the detections outlined in this report.

| Field Name (IIS/Apache) | Description | Security Relevance Example |
| :---- | :---- | :---- |
| c-ip / %h | The IP address of the client making the request. | The primary identifier for attributing activity to a source. Used for tracking attacker movements and correlating events. |
| cs-method / %m | The HTTP method used (e.g., GET, POST, HEAD). | Distinguishing between data retrieval (GET) and data submission (POST) is key to identifying uploads or command execution. |
| cs-uri-stem / %U | The path of the requested resource (e.g., /index.html). | The primary field for identifying access to malicious files (web shells) or probes for sensitive paths. |
| cs-uri-query / %q | The query string portion of the URL (after the '?'). | A common location for injection payloads (SQLi, RCE) and command parameters for web shells. |
| sc-status / %\>s | The HTTP status code returned by the server (e.g., 200, 404, 500). | Essential for identifying scanning activity (high rates of 404s) and successful vs. failed exploit attempts. |
| cs(User-Agent) / %{User-Agent}i | The identification string of the client's browser or tool. | Critical for detecting non-standard tools (e.g., curl, python-requests) and performing frequency analysis to find anomalous clients. |
| cs(Referer) / %{Referer}i | The URL of the page that linked to the requested resource. | The absence of a referrer for a script file is a strong indicator of direct access, a hallmark of web shell interaction. |
| time-taken / %D | The time in milliseconds/microseconds for the server to process the request. | Used to detect time-based blind SQL injection attacks, which manifest as anomalous delays in server response. |

### **1.2. Normalization and Abstraction: The Splunk Web Data Model**

Writing detection queries directly against raw log formats is inefficient and brittle. A query written for Apache's Combined Log Format will fail on IIS logs, and vice versa. To solve this, a layer of abstraction is needed. The Splunk Common Information Model (CIM) provides this by defining a standardized set of fields and event categories.11

For web server logs, the Web data model is the target schema. It acts as a "schema on read," allowing analysts to write a single, normalized query that works seamlessly across data from Apache, IIS, Nginx, or any other web server, provided the data has been correctly onboarded and mapped to the CIM.11 For example, a query using

Web.src will automatically work with the c-ip field from IIS logs and the %h field from Apache logs.

This abstraction is not merely a convenience; it is a requirement for building a mature and scalable detection program. It allows detections to be shared, reused, and integrated into higher-level frameworks like Splunk Enterprise Security without modification.

A crucial point to understand is that access logs are a record of *intent*, not *outcome*. They meticulously document the *request* sent by a client—the URI, the method, the headers—and the server's HTTP response code.10 However, they do not and cannot show the

*effect* of that request on the server's operating system. For instance, a log can show a POST request to shell.php containing command parameters, but it cannot show the resulting cmd.exe process being spawned by the web server's worker process (e.g., w3wp.exe for IIS). That definitive evidence of compromise resides in endpoint logs.14 Consequently, detections based solely on access logs are fundamentally

*inferential*. They identify requests that are highly correlated with malicious activity but cannot, by themselves, prove a compromise occurred. This positions web access logs as an invaluable source for threat hunting and an essential tripwire that must be correlated with other data sources, like endpoint detection and response (EDR), for high-confidence alerting.

| CIM Field (Web model) | Description | Example Apache Field (%...) | Example IIS Field (cs-...) |
| :---- | :---- | :---- | :---- |
| src | The source of the network traffic (the client). | %h (Remote hostname/IP) | c-ip (Client IP Address) |
| http\_method | The HTTP method used in the request. | %m (Request method) | cs-method (Method) |
| uri\_path | The path of the resource served by the webserver. | %U (URL path) | cs-uri-stem (URI Stem) |
| uri\_query | The query string of the resource requested. | %q (Query string) | cs-uri-query (URI Query) |
| status | The HTTP response code from the server. | %\>s (Final status) | sc-status (Protocol Status) |
| http\_user\_agent | The user agent string from the request. | %{User-Agent}i | cs(User-Agent) |
| http\_referrer | The HTTP referrer from the request. | %{Referer}i | cs(Referer) |
| bytes | The total number of bytes transferred. | %B (Response size) | sc-bytes \+ cs-bytes |
| action | The action taken by the server (e.g., allowed, blocked). | (Derived) | (Derived) |
| dest | The destination of the traffic (the web server). | %v (Canonical ServerName) | s-ip (Server IP Address) |

## **Section 2: Detecting Initial Access (TA0001) & Execution (TA0002)**

The Initial Access and Execution tactics represent the adversary's first major objectives: getting a foothold on the server and running their code. For public-facing web servers, these actions often leave distinct traces in the access logs. This section provides detailed analyses and Splunk Processing Language (SPL) queries to detect these critical attack phases.

| MITRE Tactic | MITRE Technique (ID) | Description | Primary Access Log Indicators |
| :---- | :---- | :---- | :---- |
| Initial Access | Exploit Public-Facing Application (T1190) | Adversaries exploit weaknesses in internet-facing software, such as web applications or servers, to gain entry. | Suspicious strings in URI/query (RCE, SQLi), anomalous response times, unusual error patterns. |
| Persistence / Execution | Web Shell (T1505.003) | Adversaries install a malicious script on the server to maintain access and execute commands remotely. | Low-frequency URI access, anomalous User-Agents, absent referrers, POST-heavy interaction. |

### **2.1. Technique T1190: Exploit Public-Facing Application**

This technique is one of the most common entry vectors for attackers targeting web infrastructure.17 It involves leveraging vulnerabilities in the application code, underlying frameworks, or the web server software itself to execute arbitrary code or commands.19

#### **Sub-technique: Remote Code Execution (RCE)**

RCE vulnerabilities allow an attacker to run commands on the server as the web server's user. Payloads are often embedded directly into the HTTP request, making them visible in access logs. Vulnerabilities like Log4Shell and Text4Shell are prime examples, where specific strings (jndi:ldap://, script:javascript:) in the URI or headers trigger code execution.21 The detection strategy is to hunt for these malicious injection strings.

##### **SPL 1 (Alerting \- High Fidelity RCE Signatures)**

This query searches for known, high-confidence strings associated with common RCE vulnerabilities. It is designed for alerting, as a match has a very low false-positive rate. The query checks the URI path, query, and user agent for these patterns.

Splunk SPL

| tstats \`summariesonly\` values(Web.uri\_path) as uri\_path, values(Web.uri\_query) as uri\_query, values(Web.http\_user\_agent) as http\_user\_agent from datamodel=Web where (Web.uri\_path IN ("\*jndi:ldap\*", "\*jndi:rmi\*", "\*jndi:dns\*", "\*${lower:\*}\*", "\*${upper:\*}\*", "\*${::-\*}\*", "\*${env:\*}\*", "\*${ctx:\*}", "\*${sd:\*}") OR Web.uri\_query IN ("\*jndi:ldap\*", "\*jndi:rmi\*", "\*jndi:dns\*", "\*${lower:\*}\*", "\*${upper:\*}\*", "\*${::-\*}\*", "\*${env:\*}\*", "\*${ctx:\*}", "\*${sd:\*}") OR Web.http\_user\_agent IN ("\*jndi:ldap\*", "\*jndi:rmi\*", "\*jndi:dns\*", "\*${lower:\*}\*", "\*${upper:\*}\*", "\*${::-\*}\*", "\*${env:\*}\*", "\*${ctx:\*}", "\*${sd:\*}")) by Web.src, Web.dest, \_time  
| \`drop\_dm\_object\_name("Web")\`  
| \`security\_content\_ctime(firstTime)\`  
| \`security\_content\_ctime(lastTime)\`  
| eval full\_uri=uri\_path \+ "?" \+ uri\_query  
| rex field=full\_uri "(?\<rce\_payload\>\\${.+})"  
| rex field=http\_user\_agent "(?\<rce\_payload\_ua\>\\${.+})"  
| eval matched\_payload=coalesce(rce\_payload, rce\_payload\_ua)  
| rename src as "Source IP", dest as "Destination Server", matched\_payload as "Detected RCE Payload"  
| table "Source IP", "Destination Server", full\_uri, http\_user\_agent, "Detected RCE Payload"

**Annotation:**

* | tstats... from datamodel=Web: Efficiently searches the accelerated Web data model.  
* where (Web.uri\_path IN...): The core detection logic, using wildcards to find various Log4Shell-style injection patterns in the URI path, query, and user agent. This list is derived from real-world attack patterns.23  
* | eval full\_uri=...: Reconstructs the full URI for easier analysis.  
* | rex field=...: Extracts the specific payload that triggered the match for analyst review.  
* | table...: Presents the results in a clean, human-readable format.

##### **SPL 2 (Hunting \- Broad Obfuscated RCE)**

Attackers often obfuscate their payloads to evade simple signature-based detections.23 This hunting query looks for the building blocks of obfuscation and command execution, such as chained special characters, shell commands, and encoding functions, then scores requests based on the number of suspicious indicators found.

Splunk SPL

\`datamodel("Web")\`

| eval uri=uri\_path \+ "?" \+ uri\_query  
| eval score=0  
// Score for common shell commands and binaries

| eval score=if(match(uri, "(?i)(cat|wget|curl|bash|sh|nc|ncat|powershell|cmd.exe|whoami|/etc/passwd)"), score+2, score)  
// Score for command separators and pipes

| eval score=if(match(uri, "(;|%3B|\\||%7C|&&|%26%26)"), score+1, score)  
// Score for common obfuscation/encoding functions

| eval score=if(match(uri, "(?i)(base64|char\\(|fromcharcode|eval\\(|gzinflate)"), score+3, score)  
// Score for path traversal-like sequences often used to position payloads

| eval score=if(match(uri, "(\\.\\./|\\.\\.\\\\|%2e%2e)"), score+1, score)  
// Score for OGNL-style syntax

| eval score=if(match(uri, "(\#|@|new\\s)"), score+1, score)  
| where score \> 3  
| stats count, values(uri) as uris, max(score) as max\_score by src, dest, http\_user\_agent  
| sort \- max\_score  
| rename src as "Source IP", dest as "Destination Server", http\_user\_agent as "User Agent", max\_score as "Suspicion Score", count as "Request Count"  
| table "Source IP", "Destination Server", "User Agent", "Suspicion Score", "Request Count", uris

**Annotation:**

* | eval score=0: Initializes a risk score for each event.  
* | eval score=if(match(uri,...), score+X, score): A series of if statements that increment the score based on matches with different regex patterns. Each pattern represents a different type of suspicious indicator.  
* where score \> 3: Filters the results to only show events that have accumulated a significant score, reducing noise.  
* | stats... by src, dest, http\_user\_agent: Aggregates the results by source, destination, and user agent to identify the most active and suspicious clients.  
* | sort \- max\_score: Presents the highest-risk activity first.

#### **Sub-technique: SQL Injection (SQLi)**

SQLi attacks involve injecting malicious SQL code into application inputs to manipulate backend database queries.24 In access logs, these attempts are most often visible in the

uri\_query field as SQL keywords, comment syntax, and logical tautologies (' OR 1=1).25

##### **SPL 3 (Alerting \- High Fidelity SQLi Signatures)**

This query looks for common and high-confidence SQL injection patterns in the URI query. It is suitable for alerting, particularly when correlated with POST requests, which are a common vector for form-based injection.

Splunk SPL

| tstats \`summariesonly\` values(Web.uri\_query) as uri\_query from datamodel=Web where (Web.http\_method="POST" AND Web.uri\_query IS NOT NULL) by Web.src, Web.dest, Web.uri\_path, \_time  
| \`drop\_dm\_object\_name("Web")\`  
| search (uri\_query IN ("\*' OR \*", "\*' AND \*", "\*--\*", "\*/--\*", "\*UNION\*SELECT\*", "\*'UNION\*ALL\*SELECT\*") OR match(uri\_query, "(?i)(xp\_cmdshell|sp\_configure|WAITFOR DELAY)"))  
| rename src as "Source IP", dest as "Destination Server", uri\_path as "Target Path", uri\_query as "Malicious Query"  
| table "Source IP", "Destination Server", "Target Path", "Malicious Query"

**Annotation:**

* where (Web.http\_method="POST"...): Focuses on POST requests, which are more likely to be submitting data to a backend database.  
* search (uri\_query IN...): Searches for classic SQLi patterns, including tautologies (' OR ), comments (--), and command execution functions (xp\_cmdshell).  
* match(uri\_query,...): Uses regex for more complex patterns like WAITFOR DELAY, which is indicative of a time-based blind SQLi attempt.

##### **SPL 4 (Hunting \- Time-Based Blind SQLi)**

Blind SQLi is a more subtle technique where the attacker infers database structure based on the application's response time rather than error messages.24 A time-based attack uses commands like

WAITFOR DELAY (SQL Server) or SLEEP() (MySQL) to cause a deliberate pause. This can be detected by finding requests where the time-taken is a statistical outlier for a given page.

Splunk SPL

\`datamodel("Web")\`

| where uri\_path IS NOT NULL AND time\_taken IS NOT NULL  
// Calculate the average and standard deviation of response time for each URI path

| eventstats avg(time\_taken) as avg\_time, stdev(time\_taken) as stdev\_time by uri\_path  
// Identify requests where the time taken is more than 3 standard deviations above the average

| where time\_taken \> (avg\_time \+ (3 \* stdev\_time)) AND time\_taken \> 5000  
// Filter out URIs that are consistently slow

| eventstats count as total\_requests, dc(src) as distinct\_sources by uri\_path  
| where total\_requests \> 20  
| rename src as "Source IP", dest as "Destination Server", uri\_path as "Target Path", time\_taken as "Anomalous Response Time (ms)", avg\_time as "Average Response Time (ms)"  
| table "Source IP", "Destination Server", "Target Path", "Anomalous Response Time (ms)", "Average Response Time (ms)"

**Annotation:**

* | eventstats... by uri\_path: Calculates the average (avg) and standard deviation (stdev) of time\_taken for every unique uri\_path. This establishes a performance baseline for each page.  
* | where time\_taken \> (avg\_time \+ (3 \* stdev\_time)): The core anomaly detection logic. It flags any request that is significantly slower than the norm for that specific page. 3 \* stdev is a common threshold for statistical outliers.  
* AND time\_taken \> 5000: Adds a hard threshold (5 seconds) to filter out minor fluctuations.  
* | eventstats count... where total\_requests \> 20: Ensures the baseline is calculated on a sufficient number of requests to be statistically meaningful, avoiding false positives on rarely accessed pages.

### **2.2. Technique T1505.003: Web Shells \- The Persistent Foothold**

A web shell is a script uploaded to a server that allows an adversary to execute commands, providing persistent access.26 Detecting web shells is a multi-stage process that involves looking for both the initial upload and the subsequent interaction.27 Access logs are particularly effective for detecting the interaction phase.

The attack chain is often symbiotic: a successful T1190 exploit is frequently the delivery mechanism for a T1505.003 web shell.21 This means an alert for a potential RCE or SQLi attempt from a source IP should be treated as a critical precursor. Any subsequent activity from that same IP, especially

POST requests or access to rare files, carries a much higher probability of being part of a successful compromise. This progression from a single atomic alert to a contextualized understanding of an unfolding attack is a key step in maturing a security operations program, often operationalized through risk-based alerting (RBA).

#### **Part 1 \- Detecting the Upload**

The initial upload can be difficult to distinguish from legitimate file uploads. However, we can hunt for strong indicators, such as POST requests that create new script files in writable directories.

##### **SPL 5 (Hunting \- Potential Web Shell Upload)**

This query identifies POST requests that result in the creation of a new file with a common script extension. It highlights rare filenames, which are less likely to be part of the standard application.

Splunk SPL

\`datamodel("Web")\`

| where http\_method="POST" AND status IN (200, 201\) AND (uri\_path LIKE "%.php" OR uri\_path LIKE "%.aspx" OR uri\_path LIKE "%.asp" OR uri\_path LIKE "%.jsp")  
| stats count, earliest(\_time) as first\_seen, latest(\_time) as last\_seen by src, dest, uri\_path, http\_user\_agent  
| eventstats count as uri\_count by uri\_path  
| where uri\_count \< 5  
| convert ctime(first\_seen), ctime(last\_seen)  
| sort 0 uri\_count, count  
| rename src as "Source IP", dest as "Destination Server", uri\_path as "Uploaded File Path", http\_user\_agent as "User Agent", count as "Upload Count", uri\_count as "Total Times File Seen"  
| table "Source IP", "Destination Server", "Uploaded File Path", "User Agent", "Upload Count", "Total Times File Seen", first\_seen, last\_seen

**Annotation:**

* where http\_method="POST" AND status IN (200, 201): Filters for successful file creation/upload events.  
* AND (uri\_path LIKE...): Looks for common web shell script extensions.  
* | eventstats count as uri\_count by uri\_path: Calculates the global popularity of each URI.  
* | where uri\_count \< 5: Filters to show only rarely seen file paths, which are more likely to be attacker-uploaded shells rather than legitimate application components.

#### **Part 2 \- Detecting the Interaction**

This is where access log analysis is most powerful. Adversary interaction with a web shell creates behavioral patterns that are distinct from normal user traffic.5 While attackers can obfuscate the content of their requests, they cannot easily hide the statistical anomalies their interaction creates. This makes behavioral and frequency analysis more resilient to simple evasion techniques than signature-based rules.

Key Indicators of Web Shell Interaction:

1. **Low-Frequency URI:** The shell is accessed by very few source IPs.  
2. **Anomalous User-Agent:** The attacker uses a non-browser tool or a single, static User-Agent string for all requests.  
3. **No Referrer:** Requests are made directly to the script, not by clicking a link on the site.  
4. **POST-heavy Interaction:** Commands are typically sent in the body of POST requests.

##### **SPL 6 (Hunting \- Statistical Rarity of URI Access)**

This advanced query uses tstats to perform a high-speed frequency analysis across the entire Web data model. It identifies URIs that are statistical outliers based on the number of unique clients and user agents that have accessed them, a strong indicator of a web shell or staging file.5

Splunk SPL

| tstats \`summariesonly\` dc(Web.src) as src\_count, dc(Web.http\_user\_agent) as ua\_count, count from datamodel=Web where (Web.uri\_path LIKE "%.php" OR Web.uri\_path LIKE "%.aspx" OR Web.uri\_path LIKE "%.asp" OR Web.uri\_path LIKE "%.jsp") group by Web.uri\_path  
| \`drop\_dm\_object\_name("Web")\`  
| where src\_count \<= 2 AND ua\_count \<= 2 AND count \< 50  
| sort 0 src\_count, ua\_count, count  
| rename uri\_path as "Suspicious URI", src\_count as "Distinct Source IPs", ua\_count as "Distinct User Agents", count as "Total Access Count"  
| table "Suspicious URI", "Distinct Source IPs", "Distinct User Agents", "Total Access Count"

**Annotation:**

* | tstats... dc(Web.src) as src\_count, dc(Web.http\_user\_agent) as ua\_count... group by Web.uri\_path: This is the core of the query. It efficiently calculates the distinct count (dc) of source IPs and user agents for every script file URI.  
* | where src\_count \<= 2 AND ua\_count \<= 2: This is the filter that surfaces the anomalies. It looks for files accessed by only one or two clients and with only one or two user agents, a classic pattern for a web shell.  
* AND count \< 50: Excludes files that might have low source/UA counts but are accessed very frequently (e.g., an API endpoint hit by a single server).  
* | sort 0...: Sorts the results to show the most suspicious files (lowest counts) first.

##### **SPL 7 (Alerting \- High Fidelity Web Shell Interaction)**

This query combines multiple indicators into a single, high-fidelity alert. It looks for a POST request to a script file that has no referrer and is using a suspicious, non-browser user agent.

Splunk SPL

\`datamodel("Web")\`

| where http\_method="POST" AND status=200 AND http\_referrer="-" AND (uri\_path LIKE "%.php" OR uri\_path LIKE "%.aspx" OR uri\_path LIKE "%.asp" OR uri\_path LIKE "%.jsp")  
| search (http\_user\_agent IN ("\*python\*", "\*curl\*", "\*wget\*", "\*libwww-perl\*", "\*Go-http-client\*", "\*Java/\*", "Mozilla/4.0+(compatible;+MSIE+6.0;+Windows+NT+5.1)") OR NOT http\_user\_agent IN ("\*Chrome\*", "\*Firefox\*", "\*Safari\*", "\*Edge\*", "\*MSIE\*"))  
| stats count by src, dest, uri\_path, http\_user\_agent  
| rename src as "Source IP", dest as "Destination Server", uri\_path as "Web Shell Path", http\_user\_agent as "Suspicious User Agent", count as "Request Count"  
| table "Source IP", "Destination Server", "Web Shell Path", "Suspicious User Agent", "Request Count"

**Annotation:**

* where http\_method="POST" AND status=200 AND http\_referrer="-": Filters for the core pattern: a successful POST request with no referrer.  
* search (http\_user\_agent IN...): Looks for user agents associated with command-line tools (curl, wget) or known web shell clients like "China Chopper" (Mozilla/4.0...).5  
* OR NOT http\_user\_agent IN (...): An alternative logic that flags any user agent that does *not* look like a standard web browser. This helps catch custom tools.

## **Section 3: Detecting Discovery and Defense Evasion**

After gaining initial access, adversaries often perform reconnaissance to understand the system and look for ways to access sensitive data. These actions, while sometimes subtle, can be detected in web logs by looking for patterns of probing and attempts to access unauthorized resources.

### **3.1. Technique T1083: File and Directory Discovery via Path Traversal**

Path traversal is a classic web attack where an adversary uses ../ sequences to navigate the file system and access files outside of the intended web root directory. This can be used to read configuration files (web.config), user data (/etc/passwd), or other sensitive information. Attackers frequently encode these characters (%2e%2e%2f) to bypass simple string-based filters.28

The attack lifecycle often follows a chronological narrative that can be read in the logs. An adversary might begin with broad scanning, progress to targeted discovery like path traversal, then attempt exploitation, and finally establish persistence with a web shell. This narrative structure is ideal for threat hunting. An analyst can start by looking for the "noisy" scanning activity and then pivot on the identified source IPs to see if they progressed to these later, more targeted stages of the attack.

##### **SPL 8 (Alerting \- Path Traversal Attempts)**

This query is designed to detect various forms of path traversal, including URL-encoded and double-encoded variants. Because legitimate applications should never need to use these sequences to access parent directories in a URL, a match is a high-confidence indicator of malicious activity.

Splunk SPL

\`datamodel("Web")\`

| eval uri=uri\_path \+ "?" \+ uri\_query  
| \`urldecode(uri)\`  
| where match(uri, "(\\.\\./|%2e%2e/|\\.\\.\\\\|%2e%2e\\\\)")  
| stats count, values(uri) as traversal\_uris by src, dest, http\_user\_agent  
| rename src as "Source IP", dest as "Destination Server", http\_user\_agent as "User Agent", count as "Attempt Count", traversal\_uris as "Traversal URIs"  
| table "Source IP", "Destination Server", "User Agent", "Attempt Count", "Traversal URIs"

**Annotation:**

* | eval uri=...: Combines the path and query into a single field for analysis.  
* | urldecode(uri)\`\`: This is a conceptual representation. In a real Splunk search, you would use a custom macro or app (like the URL Toolbox) to perform URL decoding. For this query's purpose, the where clause checks for both raw and encoded forms.  
* | where match(uri,...): The regex at the heart of the detection. It looks for ../ (and its encoded form %2e%2e/) as well as ..\\ (and its encoded form %2e%2e\\) to cover both Linux/Unix and Windows path styles.  
* | stats...: Aggregates the attempts to show the most persistent attackers.

### **3.2. Hunting for Scanners and Probes (Reconnaissance)**

Before launching a targeted attack, adversaries often use automated tools to scan for vulnerabilities, open directories, and sensitive files.20 This reconnaissance activity generates distinct patterns in access logs that can serve as an early warning of an impending attack.

##### **SPL 9 (Hunting \- High Error Rate Scanning)**

Vulnerability and directory scanners work by making a large number of requests for common but often non-existent paths. This results in an anomalously high ratio of 404 Not Found or 403 Forbidden errors compared to successful 200 OK responses from a single source IP.

Splunk SPL

| tstats \`summariesonly\` count from datamodel=Web by Web.src, Web.status  
| \`drop\_dm\_object\_name("Web")\`  
| stats values(eval(if(status\>=200 AND status\<=299, count, 0))) as success\_count, values(eval(if(status\>=400 AND status\<=499, count, 0))) as client\_error\_count, values(eval(if(status\>=500 AND status\<=599, count, 0))) as server\_error\_count by src  
| eval success\_count=mvsum(success\_count), client\_error\_count=mvsum(client\_error\_count), server\_error\_count=mvsum(server\_error\_count)  
| eval total\_requests \= success\_count \+ client\_error\_count \+ server\_error\_count  
| where total\_requests \> 100  
| eval error\_ratio \= (client\_error\_count \+ server\_error\_count) / total\_requests  
| where error\_ratio \> 0.9  
| sort \- total\_requests  
| rename src as "Source IP", total\_requests as "Total Requests", success\_count as "Successful Requests", client\_error\_count as "Client Errors (4xx)", server\_error\_count as "Server Errors (5xx)", error\_ratio as "Error Ratio"  
| table "Source IP", "Total Requests", "Successful Requests", "Client Errors (4xx)", "Error Ratio"

**Annotation:**

* | tstats... by Web.src, Web.status: Efficiently counts the number of events for each source IP and status code combination.  
* | stats values(eval(if(...))): Pivots the data, creating separate columns for successful requests (2xx), client errors (4xx), and server errors (5xx).  
* | where total\_requests \> 100: Focuses on sources that have generated a significant volume of traffic.  
* | eval error\_ratio \=...: Calculates the ratio of error responses to total responses.  
* | where error\_ratio \> 0.9: Flags source IPs where more than 90% of their requests resulted in an error, a strong indicator of automated scanning.

##### **SPL 10 (Hunting \- Sensitive File Probing)**

Scanners also look for specific files that can leak information or provide access, such as configuration files, environment files, or exposed source code repositories. This query hunts for requests targeting a list of these sensitive files.

Splunk SPL

// Create a lookup file named 'sensitive\_files.csv' with a single column 'uri\_path\_pattern'  
// containing patterns like: /.git/config, /.env, /wp-config.php, /phpinfo.php, /solr/admin/info/system, /etc/passwd, /WEB-INF/web.xml

\`datamodel("Web")\`

| lookup sensitive\_files.csv uri\_path\_pattern AS uri\_path OUTPUT uri\_path\_pattern  
| where isnotnull(uri\_path\_pattern)  
| stats count, values(uri\_path) as accessed\_paths by src, dest  
| sort \- count  
| rename src as "Source IP", dest as "Destination Server", count as "Probing Attempts", accessed\_paths as "Targeted Sensitive Paths"  
| table "Source IP", "Destination Server", "Probing Attempts", "Targeted Sensitive Paths"

**Annotation:**

* | lookup sensitive\_files.csv...: This query relies on a pre-defined lookup file (sensitive\_files.csv) that contains a list of URI patterns to search for. This makes the detection easily extensible without modifying the SPL.  
* | where isnotnull(uri\_path\_pattern): Filters the web traffic to only include requests that match a pattern in the lookup file.  
* | stats...: Aggregates the results to show which source IPs are most actively probing for these sensitive files.

## **Section 4: Operationalizing Detections and Advanced Correlation**

Developing a set of SPL queries is only the first step. To be effective in a real-world Security Operations Center (SOC), these detections must be tuned, managed, and integrated into a broader security context. This section provides practical guidance on operationalizing the detections from this report and addressing the inherent limitations of relying on a single data source.

### **4.1. Tuning, False Positives, and Alert Fidelity**

Raw detections, especially behavioral and statistical ones, will inevitably generate false positives. The process of tuning is critical to increasing alert fidelity and reducing analyst fatigue. This process reflects the real-world lifecycle of a detection rule: it often begins as a broad *hypothesis* tested with a *hunting query*. The results are analyzed to identify patterns that can be distilled into a higher-fidelity *alerting query*. That alert is then deployed and undergoes continuous *tuning* to adapt to the specific environment.

* **Whitelisting Strategies:** The most common source of false positives is legitimate activity that mimics malicious behavior. Internal vulnerability scanners, for example, will trigger scanning detections (SPL 9). A specific administrative script might be accessed rarely from a single IP, triggering the web shell detection (SPL 6). The solution is to create and maintain lookup files to whitelist known-good activity.  
  * ip\_whitelist.csv: Contains IP addresses of known vulnerability scanners, monitoring tools, and administrative workstations.  
  * uri\_whitelist.csv: Contains specific URI paths that are known to generate false positives for certain rules.  
  * These lookups can be incorporated into queries with a | search NOT \[| inputlookup ip\_whitelist.csv | fields src\] clause to filter out benign events before they become alerts.  
* **From Hunting to Alerting:** A broad hunting query like SPL 4 (Time-Based Blind SQLi) is not suitable for real-time alerting as-is because "normal" response times can fluctuate. To operationalize it, a baseline must be established. This can be done using the timewrap command in Splunk to compare today's average response time for a URI against the average from the previous 7 or 30 days. An alert would only fire if there is a significant, sustained deviation from the historical norm.  
* **Alert Throttling:** A single scanning event can trigger hundreds of log entries in a minute. To prevent an alert storm, Splunk's built-in alert throttling should be used. For example, an alert can be configured to fire only once for a given source IP and destination server combination within a 1-hour window.

### **4.2. Beyond Access Logs: Correlating for Context (The Visibility Gap)**

As established, access logs provide an inferential view of an attack. They show the request, but not the result on the operating system. To achieve high-confidence, definitive detection of a compromise, web log data must be correlated with other data sources, primarily endpoint logs.

The highest-fidelity detection for a web shell is not a pattern in the web log, but a process anomaly on the server itself: a web server worker process (w3wp.exe, httpd, nginx) spawning a command-line interpreter (cmd.exe, powershell.exe, /bin/bash).14 This is an almost certain indicator of compromise.

#### **Conceptual Correlation Search**

This process can be automated in a SIEM or performed manually by an analyst during an investigation. The workflow is as follows:

1. **Initial Tripwire:** An alert fires from an access-log-based detection, such as SPL 7 (High Fidelity Web Shell Interaction). The alert provides the source IP (1.2.3.4), the destination server (WEB\_SERVER\_01), the suspicious URI (/uploads/shell.php), and the timestamp (T).  
2. **Pivot to Endpoint Data:** The analyst (or a SOAR playbook) immediately runs a second, correlated search against the endpoint data, normalized in the Splunk Endpoint data model.  
3. **Confirmation Query:**  
   Splunk SPL

| tstats summariesonly count from datamodel=Endpoint where (nodename="WEB\_SERVER\_01" AND Endpoint.parent\_process IN ("w3wp.exe", "httpd", "nginx", "apache2") AND Endpoint.process\_name IN ("cmd.exe", "powershell.exe", "pwsh.exe", "sh", "bash", "cscript.exe")) by \_time, Endpoint.parent\_process, Endpoint.process, Endpoint.user  
| drop\_dm\_object\_name("Endpoint")  
| convert ctime(\_time)  
\`\`\`  
This query is run with a narrow time window around the initial web alert (e.g., earliest=T-1m latest=T+1m).

4. **Verdict:** If the second query returns any results, it provides high-confidence confirmation that the web shell interaction was successful and resulted in command execution on the server. The incident can be immediately escalated with a high degree of certainty. If it returns no results, the web log alert may have been a failed attempt or a false positive, warranting further, but less urgent, investigation.

### **Conclusions and Recommendations**

The analysis of Apache and IIS access logs provides significant opportunities for detecting adversary activity, particularly during the critical Initial Access and Execution phases of an attack. By leveraging the MITRE ATT\&CK framework as a guide, security teams can move beyond simple error monitoring to implement sophisticated, behavior-based detections.

This report has demonstrated that through careful analysis of log fields like the URI, User-Agent, and Referrer, it is possible to construct high-fidelity queries in Splunk to identify techniques such as **T1190: Exploit Public-Facing Application** and **T1505.003: Web Shells**. The use of both signature-based and statistical anomaly detection methods provides a layered defense, where high-confidence signatures catch known threats and behavioral analysis uncovers novel or obfuscated attacks.

However, the effectiveness of these detections is predicated on two key principles:

1. **Data Quality is Paramount:** The "Garbage In, Garbage Out" principle applies directly to log analysis. Without comprehensive logging enabled at the source—specifically the Combined Log Format for Apache and a fully populated W3C Extended format for IIS—the telemetry required for advanced detections will be missing. The first action for any security team must be to audit and enforce a robust logging standard across all web-facing assets.  
2. **Correlation is Key to Confirmation:** Access logs, while invaluable, provide an inferential view of attacker activity. They show the attempt but not necessarily the outcome. To bridge this visibility gap and move from inference to confirmation, correlation with endpoint data is essential.

Therefore, the final and most critical recommendation is the integration of endpoint data sources (such as EDR logs or native OS logging like Sysmon) into the security monitoring platform. Normalizing this data into the Splunk Endpoint CIM and correlating it with alerts generated from the Web data model transforms low-to-medium confidence web alerts into high-confidence indicators of compromise. This fusion of network-edge and host-level telemetry is the hallmark of a mature and effective threat detection program.

#### **Alıntılanan çalışmalar**

1. Log Files \- Apache HTTP Server Version 2.4, erişim tarihi Ağustos 11, 2025, [https://httpd.apache.org/docs/2.4/logs.html](https://httpd.apache.org/docs/2.4/logs.html)  
2. Understanding the apache access log: how to view, locate, and analyze \- Sumo Logic, erişim tarihi Ağustos 11, 2025, [https://www.sumologic.com/blog/apache-access-log](https://www.sumologic.com/blog/apache-access-log)  
3. What Do The Fields In An Apache Access Log Mean? \- Uptimia, erişim tarihi Ağustos 11, 2025, [https://www.uptimia.com/questions/what-do-the-fields-in-an-apache-access-log-mean](https://www.uptimia.com/questions/what-do-the-fields-in-an-apache-access-log-mean)  
4. Understanding Apache's access log \- Stack Overflow, erişim tarihi Ağustos 11, 2025, [https://stackoverflow.com/questions/9234699/understanding-apaches-access-log](https://stackoverflow.com/questions/9234699/understanding-apaches-access-log)  
5. Detecting Web Shells in HTTP Access Logs \- Anomali, erişim tarihi Ağustos 11, 2025, [https://www.anomali.com/blog/detecting-web-shells-in-http-access-logs](https://www.anomali.com/blog/detecting-web-shells-in-http-access-logs)  
6. mod\_log\_config \- Apache HTTP Server Version 2.4, erişim tarihi Ağustos 11, 2025, [https://httpd.apache.org/docs/current/mod/mod\_log\_config.html](https://httpd.apache.org/docs/current/mod/mod_log_config.html)  
7. IIS Log File Formats \- Microsoft Learn, erişim tarihi Ağustos 11, 2025, [https://learn.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms525807(v=vs.90)](https://learn.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms525807\(v=vs.90\))  
8. IIS Log Files: How To Interpret, Customize, Query, and Aggregate \- Stackify, erişim tarihi Ağustos 11, 2025, [https://stackify.com/how-to-interpret-iis-logs/](https://stackify.com/how-to-interpret-iis-logs/)  
9. What are IIS Logs? | CrowdStrike, erişim tarihi Ağustos 11, 2025, [https://www.crowdstrike.com/en-us/cybersecurity-101/observability/iis-logs/](https://www.crowdstrike.com/en-us/cybersecurity-101/observability/iis-logs/)  
10. List of fields in IIS W3C logs. \- FinalAnalytics, erişim tarihi Ağustos 11, 2025, [https://www.finalanalytics.com/help/httplogbrowser/field-list.html](https://www.finalanalytics.com/help/httplogbrowser/field-list.html)  
11. Web | Splunk Docs, erişim tarihi Ağustos 11, 2025, [https://help.splunk.com/en/splunk-cloud-platform/common-information-model/6.0/data-models/web](https://help.splunk.com/en/splunk-cloud-platform/common-information-model/6.0/data-models/web)  
12. About data models \- Splunk Documentation, erişim tarihi Ağustos 11, 2025, [https://docs.splunk.com/Documentation/Splunk/9.4.2/Knowledge/Aboutdatamodels](https://docs.splunk.com/Documentation/Splunk/9.4.2/Knowledge/Aboutdatamodels)  
13. Apache log format \- Wikitech \- Wikimedia, erişim tarihi Ağustos 11, 2025, [https://wikitech.wikimedia.org/wiki/Apache\_log\_format](https://wikitech.wikimedia.org/wiki/Apache_log_format)  
14. Summary of Tactics, Techniques and Procedures Used to Target Australian Networks | Cyber.gov.au, erişim tarihi Ağustos 11, 2025, [https://www.cyber.gov.au/about-us/advisories/summary-tactics-techniques-and-procedures-used-target-australian-networks](https://www.cyber.gov.au/about-us/advisories/summary-tactics-techniques-and-procedures-used-target-australian-networks)  
15. Webshell Detection: Script Process Child of Common Web Processes | Elastic Security Solution \[8.17\], erişim tarihi Ağustos 11, 2025, [https://www.elastic.co/guide/en/security/8.17/prebuilt-rule-1-0-2-webshell-detection-script-process-child-of-common-web-processes.html](https://www.elastic.co/guide/en/security/8.17/prebuilt-rule-1-0-2-webshell-detection-script-process-child-of-common-web-processes.html)  
16. Detect Webshell Exploit Behavior | Splunk Security Content, erişim tarihi Ağustos 11, 2025, [https://research.splunk.com/endpoint/22597426-6dbd-49bd-bcdc-4ec19857192f/](https://research.splunk.com/endpoint/22597426-6dbd-49bd-bcdc-4ec19857192f/)  
17. Exploit Public-Facing Application, Technique T1190 \- Enterprise ..., erişim tarihi Ağustos 11, 2025, [https://attack.mitre.org/techniques/T1190/](https://attack.mitre.org/techniques/T1190/)  
18. What is MITRE ATT\&CK Initial Access (TA0001)? \- Netscout, erişim tarihi Ağustos 11, 2025, [https://www.netscout.com/what-is-mitre-attack/initial-access](https://www.netscout.com/what-is-mitre-attack/initial-access)  
19. What are MITRE ATT\&CK initial access techniques \- GitGuardian Blog, erişim tarihi Ağustos 11, 2025, [https://blog.gitguardian.com/inital-access-techniques/](https://blog.gitguardian.com/inital-access-techniques/)  
20. What Is Initial Access? MITRE ATT\&CK® Initial Access Tactic | TA0001 \- SOC Prime, erişim tarihi Ağustos 11, 2025, [https://socprime.com/blog/what-is-initial-access-mitre-attck-initial-access-tactic-ta0001/](https://socprime.com/blog/what-is-initial-access-mitre-attck-initial-access-tactic-ta0001/)  
21. Ransomware Prevention and Detection in the Initial Phase of Attack Lifecycle from the Defender's Perspective \- Picus Security, erişim tarihi Ağustos 11, 2025, [https://www.picussecurity.com/resource/ransomware-prevention-and-detection-in-the-initial-phase-of-attack-lifecycle-from-the-defenders-perspective](https://www.picussecurity.com/resource/ransomware-prevention-and-detection-in-the-initial-phase-of-attack-lifecycle-from-the-defenders-perspective)  
22. Detection: Exploit Public Facing Application via Apache Commons Text, erişim tarihi Ağustos 11, 2025, [https://research.splunk.com/web/19a481e0-c97c-4d14-b1db-75a708eb592e/](https://research.splunk.com/web/19a481e0-c97c-4d14-b1db-75a708eb592e/)  
23. Simulating, Detecting, and Responding to Log4Shell with Splunk, erişim tarihi Ağustos 11, 2025, [https://www.splunk.com/en\_us/blog/security/simulating-detecting-and-responding-to-log4shell-with-splunk.html](https://www.splunk.com/en_us/blog/security/simulating-detecting-and-responding-to-log4shell-with-splunk.html)  
24. What is SQL Injection? \- Splunk, erişim tarihi Ağustos 11, 2025, [https://www.splunk.com/en\_us/blog/learn/sql-injection.html](https://www.splunk.com/en_us/blog/learn/sql-injection.html)  
25. Leveraging IIS web server auditing for network security \- ManageEngine, erişim tarihi Ağustos 11, 2025, [https://www.manageengine.com/products/eventlog/user-interface/iis-server-logs.html](https://www.manageengine.com/products/eventlog/user-interface/iis-server-logs.html)  
26. Server Software Component, Technique T1505 \- Enterprise | MITRE ATT\&CK®, erişim tarihi Ağustos 11, 2025, [https://attack.mitre.org/techniques/T1505/](https://attack.mitre.org/techniques/T1505/)  
27. Server Software Component: Web Shell, Sub-technique T1505.003 ..., erişim tarihi Ağustos 11, 2025, [https://attack.mitre.org/techniques/T1505/003/](https://attack.mitre.org/techniques/T1505/003/)  
28. Detection: Splunk Path Traversal In Splunk App For Lookup File Edit, erişim tarihi Ağustos 11, 2025, [https://research.splunk.com/application/8ed58987-738d-4917-9e44-b8ef6ab948a6/](https://research.splunk.com/application/8ed58987-738d-4917-9e44-b8ef6ab948a6/)  
29. Detection: Path traversal SPL injection \- Splunk Security Content, erişim tarihi Ağustos 11, 2025, [https://research.splunk.com/application/dfe55688-82ed-4d24-a21b-ed8f0e0fda99/](https://research.splunk.com/application/dfe55688-82ed-4d24-a21b-ed8f0e0fda99/)