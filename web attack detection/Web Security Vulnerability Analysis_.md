

# **The Comprehensive Guide to Modern Web Application Vulnerabilities: Detection, Exploitation, and Analysis**

## **Introduction**

Web applications have become the central interface for modern commerce, communication, and data exchange. Their complexity and ubiquity, however, have introduced a vast and evolving attack surface. From legacy systems still vulnerable to classic injection flaws to modern, API-driven architectures susceptible to nuanced logic abuse, the spectrum of potential security risks is broader than ever. For cybersecurity professionals—be they penetration testers, application security engineers, or security operations center (SOC) analysts—a deep, functional understanding of these vulnerabilities is not merely advantageous; it is essential for effective defense, detection, and response.

This report provides an exhaustive technical analysis of 30 critical web application security topics. It is structured to serve as a definitive reference guide for practitioners, moving beyond high-level summaries to offer detailed dissections of each vulnerability's core mechanism, a thorough examination of manual and automated detection methodologies, and practical, actionable detection strategies using the Splunk platform. The analysis is organized into three distinct parts:

* **Part I: A Comprehensive Catalog of Web Application Vulnerabilities** systematically examines each vulnerability, grouped by its fundamental attack class. This section details the "what" and "how" of each threat, from foundational injection flaws to sophisticated attacks against modern protocols and architectures.  
* **Part II: Detection Engineering with the Splunk Web Data Model** translates theoretical knowledge into operational capability. It provides a master table of Splunk Processing Language (SPL) queries, tailored to the Web Data Model, designed to identify the behavioral artifacts and indicators of compromise associated with the vulnerabilities discussed.  
* **Part III: Essential Competencies for the Modern Web Security Professional** synthesizes the preceding analysis into a holistic skill matrix. It outlines the technical foundations, offensive acumen, defensive engineering capabilities, and secure development knowledge required to excel in the field of web application security.

By integrating detailed vulnerability analysis with practical detection engineering and a strategic overview of required professional skills, this report aims to equip cybersecurity professionals with the comprehensive knowledge necessary to navigate and secure the complex landscape of modern web applications.

---

## **Part I: A Comprehensive Catalog of Web Application Vulnerabilities**

This section provides a systematic analysis of web application vulnerabilities, categorized by their underlying principles of exploitation. Each topic is explored in detail, covering its definition, core mechanism, impact, and a thorough review of detection methods.

### **Section 1: The Injection Flaw Pantheon**

Injection vulnerabilities represent a broad class of attacks that occur when an application sends untrusted data to an interpreter as part of a command or query. The core of the flaw lies in the interpreter's inability to distinguish between legitimate data and attacker-supplied commands, leading to unintended execution.1 This failure to properly validate, sanitize, or separate user-controlled input from the logic of back-end interpreters is the common thread connecting this entire category of vulnerabilities. Whether the interpreter is a SQL database, an operating system shell, a web browser, or a template engine, the attack pattern of context-switching—from data to command—remains the same. This fundamental design flaw often results in the most critical security breaches, including data exfiltration, authentication bypass, and complete system compromise.

#### **1.1 SQL Injection (SQLi)**

**Summary**

SQL Injection (SQLi) is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. It consists of inserting or "injecting" a malicious SQL query via user-supplied input.2 A successful exploit can read sensitive data from the database, modify or delete data, execute administrative operations on the database (such as shutting down the DBMS), and in some cases, issue commands to the host operating system.2

The vulnerability arises when an application dynamically constructs a SQL query using user input without proper validation or the use of parameterized queries. SQL makes no inherent distinction between its control plane (the commands) and its data plane (the values being queried), allowing an attacker to insert metacharacters like single quotes (') or semicolons (;) to break out of the data context and introduce new SQL commands.2 The impact of a successful SQLi attack is typically severe, affecting confidentiality, integrity, and availability, and is limited primarily by the attacker's skill and the privileges of the database connection.2

There are several types of SQLi:

* **In-band SQLi:** The most direct form, where the attacker uses the same communication channel to launch the attack and gather results. A common technique is the UNION-based attack, which uses the UNION SQL operator to combine the results of a malicious query with the legitimate query's results, thereby exfiltrating data from other tables.3  
* **Inferential (Blind) SQLi:** This is used when the application does not return the results of the query or database errors directly in its HTTP response. The attacker must infer the database structure and data by observing the application's behavior. This is achieved by asking a series of true/false questions via injected queries and monitoring for differences in the response. Techniques include triggering conditional responses (e.g., a "Welcome back" message appearing only if a condition is true), conditional errors, or time delays (e.g., using WAITFOR DELAY or pg\_sleep).3  
* **Out-of-band SQLi:** This technique is used when the server's response is not stable or timely. The attacker causes the database server to make an out-of-band connection to a system they control, exfiltrating data through protocols like DNS or HTTP.4

**Detection Methods**

Detection of SQLi involves both manual testing and the use of automated tools to probe for vulnerabilities in application entry points.

* **Manual Detection:** The primary manual technique is to probe every user-controllable input (URL parameters, form fields, HTTP headers) with SQL-specific syntax and observe the application's response for anomalies.5  
  1. **Inducing Errors:** Submit a single quote character (') to see if it breaks the query syntax and returns a database error message. Messages like "syntax error" or "unclosed quotation mark" are strong indicators of a vulnerability.3  
  2. **Boolean Conditions:** Inject logical conditions that evaluate to true and false, such as OR 1=1 and OR 1=2, and look for systematic differences in the application's responses. For example, a true condition might return all records, while a false one returns none.2  
  3. **Time Delays:** For blind SQLi, inject payloads designed to trigger a time delay if a condition is true. For example, IF (1=1) WAITFOR DELAY '0:0:10' on Microsoft SQL Server. A noticeable delay in the HTTP response confirms the vulnerability.5  
  4. **Out-of-Band (OAST) Detection:** Use payloads that trigger an out-of-band network interaction with a tool like Burp Collaborator. For instance, a payload could force the database to perform a DNS lookup to a unique, attacker-controlled domain.5  
* **Automated Detection:**  
  1. **Dynamic Application Security Testing (DAST):** Tools like Burp Scanner can automatically audit an application by sending a battery of SQLi payloads to all identified entry points and analyzing the responses for signs of vulnerability.3  
  2. **Fuzzing with Burp Intruder:** A more targeted approach involves using Burp Intruder to send a list of SQL fuzz strings to a specific parameter. This is useful for closely investigating a potential flaw or attempting to bypass web application firewalls (WAFs).7  
  3. **Specialized Tools:** SQLMap is a popular open-source tool that automates the process of detecting and exploiting SQLi vulnerabilities, supporting a wide range of database systems and attack techniques.3

#### **1.2 NoSQL Injection**

**Summary**

NoSQL injection is a vulnerability where an attacker interferes with queries made to a NoSQL database, such as MongoDB, Cassandra, or Neo4j. Similar to SQLi, it arises from insufficient validation of user-supplied input that is directly incorporated into database queries.8 However, the attack vectors differ significantly because NoSQL databases use a variety of query languages and data structures (often JSON-based) instead of a universal standard like SQL.8

A successful NoSQL injection can allow an attacker to bypass authentication, extract or modify data, cause a denial of service, or, in some cases, achieve remote code execution.10 The impact can be greater than traditional SQLi because some NoSQL queries are executed within a procedural language, offering more control to an attacker.11

There are two main types of NoSQL injection:

* **Syntax Injection:** The attacker breaks the query syntax to inject their own payload. This is analogous to classic SQLi but uses the syntax of the specific NoSQL database's query language.10  
* **Operator Injection:** The attacker injects NoSQL query operators (e.g., MongoDB's $ne, $gt, $in, $where) to manipulate the logic of a query. This is a common vector, as many NoSQL queries are constructed as structured objects (like JSON), and an attacker can inject a nested object containing a malicious operator.8 For example, an authentication query checking for  
  {"username":"user", "password":"pwd"} could be bypassed by submitting {"username":{"$ne":"a"}, "password":{"$ne":"b"}}, which finds the first user whose username and password are not equal to "a" and "b" respectively.9  
* **Server-Side JavaScript Injection (SSJI):** A particularly dangerous variant that occurs in databases like MongoDB, which support operators like $where that can execute arbitrary JavaScript on the server. If an attacker can inject into a $where clause, they can potentially exfiltrate data or perform other malicious actions.8

**Detection Methods**

Detecting NoSQL injection requires understanding the specific database technology in use and its query syntax.

* **Manual Detection:**  
  1. **Syntax Probing:** Systematically test inputs with characters that have special meaning in JavaScript and JSON, such as ', ", \\, {, }, \[, \], and $. A database error or unexpected application behavior can indicate a vulnerability.10  
  2. **Conditional Behavior:** As with SQLi, send requests with conditions that evaluate to true and false to see if the application's response changes. For JavaScript-based queries, this could be ' && 0 && 'x (false) versus ' && 1 && 'x (true).10  
  3. **Operator Injection Testing:** Test if query operators can be injected. For URL parameters, this might look like username\[$ne\]=invalid. If that fails, try converting the request from GET to POST with a Content-Type of application/json and submitting a JSON body with the operator as a nested object: {"username":{"$ne":"invalid"}}.10  
  4. **Timing Attacks:** For blind scenarios where the response does not change, use payloads that trigger a time delay. For example, in MongoDB, injecting into a $where clause with sleep(5000) would cause a 5-second delay if the injection is successful.10  
* **Automated Detection:**  
  1. **DAST Scanners:** Automated scanners like Burp Scanner can be used to probe for NoSQL injection vulnerabilities, although their effectiveness may vary depending on their knowledge of specific NoSQL database technologies.10  
  2. **Fuzzing:** Using tools like Burp Intruder with custom payload lists containing NoSQL operators and JavaScript syntax is an effective method for systematically testing parameters for operator and syntax injection vulnerabilities.13

#### **1.3 Command Injection**

**Summary**

Command injection, also known as OS command injection or shell injection, is a critical vulnerability that allows an attacker to execute arbitrary commands on the host operating system through a vulnerable application.14 The attack is possible when an application passes unsafe, user-supplied data (from forms, cookies, HTTP headers, etc.) to a system shell. The injected commands are typically executed with the same privileges as the vulnerable application, which can lead to a full compromise of the web server.14

This vulnerability is distinct from code injection. In code injection, the attacker adds their own code that is then executed by the application's interpreter (e.g., PHP, Python). In command injection, the attacker extends the default functionality of the application, which is already executing system commands, by injecting additional commands to be run by the OS shell.14 The root cause is almost always insufficient input validation, where the application fails to sanitize or reject input containing shell metacharacters.14

**Detection Methods**

Detection involves probing input vectors with shell metacharacters and commands to observe their effect on the application's behavior.

* **Manual Detection:**  
  1. **Injecting Command Separators:** Use shell metacharacters to append a command to the legitimate input. Common separators include ;, &, &&, |, and || for both Unix-like and Windows systems, and the newline character (\\n or 0x0a) for Unix-like systems.14 A simple test involves injecting a command like  
     & whoami or ; id.  
  2. **Observing Direct Output:** If the application's output is returned in the HTTP response, the result of the injected command (e.g., the current username) will be visible, confirming the vulnerability.  
  3. **Blind Detection Techniques:** When the command's output is not visible, blind techniques are necessary.18  
     * **Time Delays:** Inject a command that causes a verifiable time delay, such as ping \-c 10 127.0.0.1 (for a 10-second delay). A delayed HTTP response indicates successful command execution.18  
     * **Output Redirection:** Redirect the output of an injected command to a file within the web root, which can then be retrieved via a separate HTTP request. For example, & whoami \> /var/www/static/whoami.txt &.18  
     * **Out-of-Band (OAST) Interaction:** Use a command that triggers an out-of-band network interaction with a system you control. The nslookup command is ideal for this. An injected payload like & nslookup attacker.burpcollaborator.net & will cause the server to perform a DNS lookup, which can be observed on the Collaborator server, confirming the vulnerability even with no direct response.18  
* **Automated Detection:**  
  1. **DAST Scanners:** Tools like Burp Scanner can automatically test for command injection by sending a variety of payloads with different commands and metacharacters and analyzing responses for direct output, time delays, or out-of-band interactions.16  
  2. **Specialized Tools:** Burp Suite extensions like "Command Injection Attacker" are designed to generate customizable, platform-specific payloads to detect non-trivial command injection cases that generic tools might miss.20

#### **1.4 Cross-Site Scripting (XSS)**

**Summary**

Cross-Site Scripting (XSS) is a type of injection vulnerability in which malicious scripts, typically client-side JavaScript, are injected into otherwise benign and trusted websites.21 The attack occurs when a web application uses input from an untrusted source within the output it generates, without properly validating or encoding it.21 When an unsuspecting user visits the compromised page, their browser executes the malicious script because it trusts the source website. This allows the script to access any data the browser holds for that site, such as cookies and session tokens, or to rewrite the page content and perform actions on behalf of the user.21

The impact of XSS can range from annoyance to complete account compromise. The most severe attacks involve stealing the user's session cookie, allowing the attacker to hijack the session and impersonate the user.21

There are three primary types of XSS:

* **Reflected XSS (Non-Persistent):** The injected script is "reflected" off the web server, such as in a search result or an error message. The attack is delivered to the victim via a crafted link (e.g., in an email or on another site). When the victim clicks the link, the malicious script is sent to the vulnerable server, which then reflects it back to the victim's browser, where it is executed.22  
* **Stored XSS (Persistent):** The malicious script is permanently stored on the target server, for example, in a database, a comment field, or a user profile. When a victim browses to the affected page, their browser retrieves and executes the stored script.21  
* **DOM-based XSS:** The vulnerability exists entirely in the client-side code. It occurs when JavaScript takes data from an attacker-controllable source (like the URL fragment) and passes it to a sink that supports dynamic code execution (like eval() or innerHTML), causing the malicious script to be executed.24

**Detection Methods**

XSS detection involves identifying locations where user input is reflected in the application's response and then testing whether a script payload can be injected and executed.

* **Manual Detection:**  
  1. **Identify Reflected Input:** Systematically submit a unique, non-malicious string (a "canary") into every entry point of the application (URL parameters, form fields, headers) and search the raw HTML of the response to see where it is reflected.25  
  2. **Test with Basic Payloads:** Once a reflection point is found, inject a simple XSS proof-of-concept payload, such as \<script\>alert(1)\</script\>, and check if a popup alert is triggered in the browser.24 The context of the reflection (e.g., inside an HTML tag, within a JavaScript string) is crucial for crafting a successful payload.  
  3. **Bypass Filters:** If basic payloads are blocked, the application may have input filters. Testers must attempt to bypass these filters by using different HTML tags (\<img\>, \<svg\>), event handlers (onerror, onload), different encodings (HTML entity, URL), or obfuscation techniques.23  
  4. **Blind XSS Detection:** For stored XSS where the reflection point is not immediately visible (e.g., in a back-end admin panel), an out-of-band approach is needed. This involves injecting a payload that, when executed, will make an HTTP request to a server controlled by the tester, such as Burp Collaborator or a service like XSS Hunter.21  
* **Automated Detection:**  
  1. **DAST Scanners:** Tools like Burp Scanner are highly effective at finding reflected and stored XSS vulnerabilities. They crawl the application, submit a wide range of payloads to all entry points, and analyze responses for evidence of script execution.25  
  2. **Fuzzing with Burp Intruder:** For targeted testing, Burp Intruder can be used to send a large list of XSS payloads to a specific parameter, helping to enumerate which tags and attributes are permitted by the server's filters.25

#### **1.5 XML External Entity (XXE) Injection**

**Summary**

XML External Entity (XXE) injection is a web security vulnerability that allows an attacker to interfere with an application's processing of XML data.27 The flaw occurs when an XML parser is weakly configured to process external entity references within user-supplied XML input.28 XML entities are a feature that allows a document to include data from other sources. An external entity can be defined to load content from a file path or a URL.27

By injecting a malicious DOCTYPE element that defines an external entity, an attacker can exploit this vulnerability to:

* **Disclose Local Files:** Read sensitive files from the server's filesystem by using the file:// protocol (e.g., \<\!ENTITY xxe SYSTEM "file:///etc/passwd"\>).27  
* **Perform Server-Side Request Forgery (SSRF):** Force the application to make requests to internal or external systems, allowing the attacker to scan the internal network or interact with back-end services.27  
* **Cause Denial of Service (DoS):** Trigger a "billion laughs" attack by defining nested entities that expand exponentially, consuming all available memory and crashing the server.29

**Detection Methods**

Detecting XXE involves submitting crafted XML payloads and observing the application's response for signs of external entity processing.

* **Manual Detection:**  
  1. **Identify XML Input:** Find parts of the application that transmit data in XML format. If none are immediately obvious, try changing the Content-Type of POST requests to application/xml or uploading files that use XML, such as SVG or DOCX.27  
  2. **In-Band Detection:** Modify the XML data to include a DOCTYPE that defines an external entity pointing to a known local file, like /etc/passwd on Linux or C:\\windows\\win.ini on Windows. Then, reference this entity in a data field that is reflected in the response. If the file's contents appear, the application is vulnerable.27  
  3. **Blind XXE Detection:** If the application does not return the entity's value in its response, blind techniques are required.27  
     * **Out-of-Band (OAST) Interaction:** Define an external entity that points to a URL on a system you control (e.g., a Burp Collaborator domain). If the server makes a DNS lookup or HTTP request to your system, the vulnerability is confirmed.33 XML parameter entities (  
       %) are often used for this purpose.  
     * **Error-Based Exfiltration:** Craft a malicious external DTD that, when parsed, triggers an XML parsing error containing sensitive data. If the application returns the error message in its response, data can be exfiltrated.28  
* **Automated Detection:**  
  1. **DAST Scanners:** Burp Scanner can automatically test for XXE vulnerabilities. During an active scan, it will send various XXE payloads to any requests containing XML and monitor for both in-band and out-of-band interactions.31

#### **1.6 Server-Side Template Injection (SSTI)**

**Summary**

Server-Side Template Injection (SSTI) occurs when an attacker can use native template syntax to inject a malicious payload into a template, which is then executed on the server.35 Template engines are designed to generate dynamic web pages by combining static templates with data. The vulnerability arises when user-controllable input is concatenated directly into a template, rather than being passed in as data to be rendered.35 This allows the attacker to inject template directives that can manipulate the template engine, often leading to full Remote Code Execution (RCE) and complete compromise of the back-end server.35

The impact of SSTI is typically catastrophic. Even if RCE is not possible, an attacker can often read sensitive files from the server or access internal application objects, leading to further attacks.36

**Detection Methods**

Detecting SSTI is a methodical process of probing, identifying the template engine, and then exploiting it.

* **Manual Detection:**  
  1. **Detect the Vulnerability:** Fuzz input parameters with a polyglot payload containing characters used in various template syntaxes, such as ${{\<%\[%'"}}%. If the application is vulnerable, it may return an error message revealing the template engine, or it may process part of the payload, altering the response.36  
  2. **Identify the Template Engine:** Once a potential vulnerability is found, the next step is to identify the specific template engine. This can be done by submitting various template expressions and observing the output. For example:  
     * {{7\*7}} might return 49 in Twig or Jinja2.  
     * ${7\*7} might return 49 in FreeMarker.  
     * \<%= 7\*7 %\> might return 49 in ERB.  
       A decision tree can be used to systematically narrow down the engine based on its response to different syntaxes.35  
  3. **Exploit:** After identifying the engine, consult its documentation to find ways to access objects and execute code. Many engines expose a "self" or "application" object that provides access to underlying functionality, which can be leveraged to execute arbitrary commands.35  
* **Automated Detection:**  
  1. **DAST Scanners:** Tools like Burp Scanner are highly effective at detecting SSTI. They use a combination of context-probing payloads and specific expressions for different template engines, and they can analyze the responses for signs of successful template evaluation, including mathematical operations and error messages.35

### **Section 2: Failures in Identity, Session, and Access Control**

This category of vulnerabilities stems from flaws in how an application verifies who a user is (authentication), tracks them across multiple requests (session management), and determines what they are allowed to do (access control). These functions are the cornerstone of application security. Failures in this domain often exploit a misplaced trust relationship: the system trusts a weak credential, a predictable identifier, or a client-supplied claim without sufficient server-side verification. The principle of "deny by default" is the most critical mitigation for this entire class of vulnerabilities; security must be an explicit grant of permission, not an implicit assumption of trust.37 This has significant architectural implications, favoring centralized, reusable access control mechanisms over scattered, ad-hoc checks.39

#### **2.1 Authentication**

**Summary**

Authentication is the process of confirming a user's identity. Authentication vulnerabilities occur when this process is flawed, allowing an attacker to gain unauthorized access to user accounts or privileged functionality.40 Common failures include weak password policies, insecure password recovery mechanisms, improper session management, lack of brute-force protection, and missing or ineffective multi-factor authentication (MFA).40

The impact of a successful authentication bypass is typically critical, as it can lead to the complete takeover of a user's account. If an administrative account is compromised, the entire application can be at risk.42 Common attack vectors include credential stuffing (using lists of breached passwords), brute-force attacks, and exploiting flawed logic in password reset functions.40

**Detection Methods**

Detecting authentication vulnerabilities involves testing the robustness of every aspect of the login, password recovery, and session management lifecycle.

* **Manual Detection:**  
  1. **Test Password Policies:** Check for weak password requirements (e.g., short length, no complexity) and whether common passwords are blocked.41  
  2. **Probe for User Enumeration:** Attempt to log in with a valid username and an invalid password, and then with an invalid username. If the error messages differ (e.g., "Invalid password" vs. "User not found"), the application is vulnerable to username enumeration, which aids brute-force attacks.41  
  3. **Test for Brute-Force Vulnerabilities:** Use a tool like Burp Intruder to send a large number of login attempts with a list of common passwords for a known username. If there is no account lockout or rate-limiting mechanism, the application is vulnerable.40  
  4. **Analyze Password Reset Functionality:** Intercept the password reset process. Look for predictable reset tokens or tokens that are not invalidated after use. Test if the reset link can be generated for an arbitrary user by manipulating parameters.42  
  5. **Inspect Session Management:** Check if session tokens are predictable, exposed in URLs, or not properly invalidated upon logout. Look for missing security flags on cookies, such as HttpOnly and Secure.40  
* **Automated Detection:**  
  1. **DAST Scanners:** Automated tools can detect some authentication flaws, such as missing cookie attributes, weak password policies, and the absence of brute-force protection on login forms.  
  2. **Credential Stuffing Tools:** Specialized tools can be used to test an application's resilience against large-scale credential stuffing attacks.

#### **2.2 Access Control**

**Summary**

Access control, or authorization, is the mechanism that enforces policies to prevent users from acting outside of their intended permissions.38 Broken access control vulnerabilities occur when these restrictions can be bypassed, allowing attackers to access unauthorized data or functionality. This was ranked as the number one risk in the OWASP Top 10 2021, affecting 94% of tested applications.38

Common types of access control vulnerabilities include:

* **Vertical Privilege Escalation:** An attacker gains access to functionality reserved for higher-privileged users, such as administrators.43  
* **Horizontal Privilege Escalation:** An attacker gains access to resources belonging to another user with the same privilege level. This is often caused by **Insecure Direct Object References (IDOR)**, where an application exposes a direct reference to an internal object (e.g., a user ID in a URL) and fails to verify that the current user is authorized to access that object.38  
* **Context-Dependent Access Control Flaws:** A user is able to perform actions in an incorrect or illogical order, such as modifying items in a shopping cart after the payment has been completed.43

**Detection Methods**

Detecting broken access control relies heavily on manual testing, as automated tools often lack the business context to understand what actions should be permitted.

* **Manual Detection:**  
  1. **Role-Based Testing:** Create accounts with different privilege levels (e.g., standard user, administrator). Log in as the lower-privileged user and attempt to access administrative functions by directly browsing to their URLs (e.g., /admin, /manage-users). This is known as "force browsing".38  
  2. **Testing for IDOR:** As an authenticated user, identify all application functions that access user-specific data using an identifier in a parameter (e.g., ?user\_id=123, /api/orders/456). Systematically change the identifier to that of another user and observe if the application grants access to the other user's data.44  
  3. **Method-Based Access Control:** If a request to view data uses a GET method (e.g., GET /api/users/123), test if changing the method to POST, PUT, or DELETE allows for unauthorized modification or deletion of the resource.  
  4. **Referer Header Validation:** Some applications base access control on the Referer header. This is insecure and can be bypassed by manipulating the header in a tool like Burp Repeater.39  
* **Automated Detection:**  
  1. **DAST Scanners:** Tools can be configured to perform force browsing attacks using lists of common administrative paths. Some tools also allow for session-based scanning, where they can attempt to re-request URLs discovered as a high-privileged user while authenticated as a low-privileged user.  
  2. **Specialized Burp Extensions:** Extensions like "Autorize" can help automate the detection of authorization bypasses by replaying every request made as a low-privileged user with the session cookies of a high-privileged user (and vice-versa) and highlighting any discrepancies.

#### **2.3 Cross-Site Request Forgery (CSRF)**

**Summary**

Cross-Site Request Forgery (CSRF) is an attack that tricks an authenticated user into submitting a malicious request to a web application they are currently logged into.46 The attack exploits the fact that browsers automatically include authentication tokens, such as session cookies, with every request to a given domain.48 An attacker can host a malicious website with a form or script that triggers a request to a vulnerable application. If a logged-in user visits the attacker's site, their browser will unknowingly submit the forged request with their session cookie, causing the application to perform an action on the attacker's behalf.49

CSRF attacks target state-changing requests, such as changing a password, transferring funds, or making a purchase.46 The attacker does not see the response to the forged request; the action simply occurs on the victim's account.50 The impact can be severe, ranging from unauthorized transactions to full account takeover if the compromised action is, for example, changing the account's email address.46

**Detection Methods**

Detecting CSRF involves identifying state-changing requests that lack a robust, unpredictable, per-request token to verify the user's intent.

* **Manual Detection:**  
  1. **Identify State-Changing Requests:** Map the application and identify all functions that perform actions (e.g., submitting forms, API calls via POST, PUT, DELETE).  
  2. **Check for CSRF Tokens:** Inspect these requests to see if they contain a parameter that looks like a CSRF token (often named csrf\_token, \_\_RequestVerificationToken, or a random string).  
  3. **Test Token Validation:** If a token is present, test the rigor of its validation:  
     * **Remove the token:** Submit the request without the token parameter. If the request is accepted, the validation is flawed.51  
     * **Submit a blank token:** Submit the request with the token parameter present but empty.  
     * **Use another user's token:** Log in with two different accounts. Obtain a valid token from Account A and use it in a request for Account B. If the request succeeds, the token is not tied to the user session.51  
     * **Change the request method:** If a POST request is protected, try changing it to a GET request with the same parameters. Some applications fail to validate tokens on GET requests.51  
  4. **Generate a Proof-of-Concept:** If no token is present or validation is weak, use Burp Suite's "Generate CSRF PoC" feature to create a simple HTML page that will automatically submit the forged request when a user visits it.52  
* **Automated Detection:**  
  1. **DAST Scanners:** Burp Scanner and other DAST tools are effective at identifying missing CSRF tokens on forms that perform state-changing actions. They can also detect some common validation flaws.52

#### **2.4 OAuth Authentication & JWT Attacks**

**Summary**

Modern authentication and authorization often rely on token-based protocols like OAuth 2.0 and standards like JSON Web Tokens (JWTs). While powerful, misconfigurations and implementation flaws can introduce critical vulnerabilities.

* **OAuth 2.0:** An authorization framework that enables a third-party application to obtain limited access to an HTTP service on behalf of a resource owner.54 Vulnerabilities typically arise from improper implementation of the redirect-based flows (e.g., the Authorization Code grant). A common flaw is weak validation of the  
  redirect\_uri parameter, allowing an attacker to specify a malicious URI and intercept the authorization code or access token sent from the authorization server.55 The IETF's RFC 9700 outlines security best practices, strongly recommending the use of Proof Key for Code Exchange (PKCE) for all clients to mitigate authorization code injection attacks.56  
* **JWT (JSON Web Tokens):** A standard for creating self-contained access tokens that assert a number of claims.57 A JWT consists of a header, a payload, and a signature. The signature ensures the integrity of the token. Vulnerabilities arise when the signature is not properly validated, allowing an attacker to tamper with the claims in the payload (e.g., changing a user ID or elevating privileges by setting  
  isAdmin: true).57 Common JWT attacks include:  
  * **Accepting unsigned tokens (alg:none):** An attacker modifies the header to specify no algorithm, and a weak library may accept the token without a signature.57  
  * **Weak secret keys:** If the secret key used for HMAC-based algorithms (like HS256) is weak or guessable, an attacker can brute-force it and forge valid signatures for any token.58  
  * **Algorithm confusion:** An attacker changes the algorithm in the header from an asymmetric one (e.g., RS256) to a symmetric one (HS256). If the server is not configured to reject this, it may use the public key (which is known to the attacker) as the secret key for HMAC verification, allowing the attacker to forge any token.57  
  * **Header parameter injection (jku, kid):** Exploiting parameters in the JWT header to control the key used for verification, leading to signature bypass via path traversal or SSRF.58

**Detection Methods**

* **Manual Detection (OAuth):**  
  1. **Analyze the Authorization Flow:** Intercept the entire OAuth flow with a proxy.  
  2. **Test redirect\_uri Validation:** Fuzz the redirect\_uri parameter to test for open redirects or acceptance of arbitrary subdomains or paths that could be controlled by an attacker.55  
  3. **Check for PKCE:** Verify that the authorization request includes code\_challenge and code\_challenge\_method parameters and that the token request includes the corresponding code\_verifier. Public clients (like SPAs and mobile apps) that do not use PKCE are vulnerable.56  
* **Manual Detection (JWT):**  
  1. **Decode and Analyze:** JWTs are Base64Url encoded, not encrypted. Decode the header and payload to understand the claims being used.  
  2. **Test Signature Validation:** Use a tool like Burp's JWT Editor extension to modify claims in the payload (e.g., change the sub or username claim).  
  3. **Test alg:none:** Change the alg parameter in the header to none (and variants like None, NONE), remove the signature part of the token, and resubmit the request.57  
  4. **Test Algorithm Confusion:** If the token uses RS256, obtain the server's public key (often available at a .well-known/jwks.json endpoint). Change the alg header to HS256, modify the payload, and sign the token using the public key as the HMAC secret.59  
  5. **Brute-force Weak Secrets:** Use a wordlist of common secrets to try to forge a valid signature for a modified token.58  
* **Automated Detection:**  
  1. **DAST Scanners:** Burp Scanner includes checks for many common JWT vulnerabilities, including weak secrets and signature bypass techniques.  
  2. **Specialized Tools:** Various open-source tools exist specifically for testing JWTs by automating the process of decoding, tampering, and testing for known vulnerabilities.

### **Section 3: Server and Request Manipulation Vulnerabilities**

This class of vulnerabilities exploits the trust and processing logic between different components of a web architecture, such as front-end proxies, back-end application servers, and file systems. Unlike flaws in application logic, these attacks often target the infrastructure itself, manipulating how HTTP requests are parsed, routed, and handled. A common theme is the exploitation of discrepancies in how different systems interpret the same request, leading to unexpected and dangerous behavior. This highlights that modern application security extends beyond the application code and requires a deep understanding of the entire request lifecycle and the configuration of every system it traverses.

#### **3.1 Server-Side Request Forgery (SSRF)**

**Summary**

Server-Side Request Forgery (SSRF) is a web security vulnerability that allows an attacker to induce a server-side application to make HTTP requests to an arbitrary location.60 The vulnerability arises when an application fetches a remote resource based on user-supplied input (e.g., a URL) without proper validation.60 The malicious request is sent from the vulnerable server's own IP address, effectively acting as a proxy.

This allows an attacker to bypass firewalls and other network access controls, enabling them to:

* **Scan internal networks:** Probe for open ports and services on internal, non-routable IP addresses.62  
* **Access internal services:** Interact with internal-only applications, databases, or APIs that may have weaker security postures.61  
* **Query cloud metadata services:** A primary target for SSRF is the metadata endpoint in cloud environments (e.g., http://169.254.169.254/ on AWS, Azure, and GCP), which can expose sensitive information like access credentials, leading to full cloud account compromise.62  
* **Read local files:** Use the file:// protocol to read arbitrary files from the server's filesystem.63

There are two main types of SSRF:

* **Basic SSRF:** The response from the back-end request is returned to the attacker in the application's front-end response.60  
* **Blind SSRF:** The application does not return the response from the back-end request. The attacker must use out-of-band techniques (like triggering an HTTP request or DNS lookup to a server they control) or infer the result based on response times or error messages.60

**Detection Methods**

Detecting SSRF involves identifying functionality where the application makes requests to external URLs and then testing if that URL can be manipulated to target internal systems.

* **Manual Detection:**  
  1. **Find the Attack Surface:** Look for any parameters in the application that appear to accept a URL, hostname, or IP address. Common examples include importing a user's profile picture from a URL, webhook configurations, or document rendering services.62  
  2. **Test Internal Endpoints:** Provide URLs that point to the server itself (http://127.0.0.1, http://localhost) or other internal services. Observe the application's response for error messages or content that indicates a successful connection.61  
  3. **Use Out-of-Band (OAST) Detection:** For both basic and blind SSRF, the most reliable detection method is to provide the URL of a system you control, such as a Burp Collaborator domain. If the application makes a DNS lookup or HTTP request to your Collaborator domain, the vulnerability is confirmed.66  
  4. **Bypass Filters:** Applications may use blacklists to block certain hostnames or IP addresses. Test for bypasses using:  
     * Alternative IP representations (e.g., decimal 2130706433 for 127.0.0.1).61  
     * Registering a domain name that resolves to an internal IP.61  
     * URL encoding or case variation to obfuscate blocked strings.61  
     * Exploiting open redirection vulnerabilities on a whitelisted domain to redirect to an internal target.61  
* **Automated Detection:**  
  1. **DAST Scanners:** Burp Scanner is highly effective at detecting SSRF. It automatically injects Burp Collaborator payloads into all relevant parameters and monitors for out-of-band interactions, reliably identifying both basic and blind SSRF vulnerabilities.66

#### **3.2 Path Traversal**

**Summary**

Path traversal, also known as directory traversal, is a vulnerability that allows an attacker to read arbitrary files on the server that is running an application.68 The attack involves manipulating user-supplied input that is used to construct a file path. By injecting path traversal sequences like

../ (dot-dot-slash) or their variations, an attacker can navigate outside of the intended web root directory and access files elsewhere on the filesystem.69

A successful path traversal attack can lead to the disclosure of highly sensitive information, including application source code, configuration files containing credentials, and critical system files like /etc/passwd on Linux systems.68 This information can then be used to mount further attacks against the system.

**Detection Methods**

Detection involves identifying parameters that affect file access and probing them with traversal sequences.

* **Manual Detection:**  
  1. **Identify Potential Vectors:** Look for parameters in the URL or request body that appear to reference filenames or resources, such as ?file=product.jpg or ?template=main.php.  
  2. **Probe with Traversal Payloads:** Systematically test these parameters by injecting traversal sequences. Start with a simple payload like ../../../../etc/passwd. It is important to try various forms of encoding, as simple filters may block plain text sequences 70:  
     * URL encoding: ..%2f, ..%5c  
     * Double URL encoding: %252e%252e%255c  
     * Non-standard encodings: ..%c0%af  
  3. **Null Byte Injection:** In some older systems (e.g., PHP, Java), a URL-encoded null byte (%00) can be used to terminate the filename, bypassing filters that append a required file extension. For example, ?file=../../../../etc/passwd%00.jpg might be processed by the OS as /etc/passwd.70  
  4. **Absolute Paths:** Test for absolute path traversal by providing full file paths like /etc/passwd or C:\\boot.ini.70  
* **Automated Detection:**  
  1. **DAST Scanners:** Tools like Burp Scanner can automatically test for path traversal vulnerabilities by sending a comprehensive set of encoded and obfuscated payloads to all relevant parameters.72  
  2. **Fuzzing:** Burp Intruder can be used with a predefined "Fuzzing \- path traversal" payload list to systematically test a specific parameter for vulnerabilities.72

#### **3.3 HTTP Host Header Attacks**

**Summary**

HTTP Host header attacks exploit vulnerabilities in how web applications process the Host request header. The Host header is mandatory in HTTP/1.1 and specifies the domain name the client wants to access, which is crucial for routing requests when a single server hosts multiple websites (virtual hosts).73 The vulnerability arises when an application implicitly trusts the value of the

Host header, which is fully controllable by an attacker.73

By supplying a malicious Host header, an attacker can manipulate server-side behavior, leading to a range of attacks:

* **Web Cache Poisoning:** An attacker can poison the cache by crafting a request with a malicious Host header. If the response, which may now contain malicious content based on the header, is cached, it will be served to all subsequent users requesting the legitimate domain.73  
* **Password Reset Poisoning:** If an application uses the Host header to construct absolute URLs in password reset emails, an attacker can inject their own domain. When the victim clicks the reset link, the reset token is sent to the attacker's server, allowing for account takeover.73  
* **Routing-based SSRF:** In complex architectures with reverse proxies or load balancers, the Host header might be used to determine where to route the request. A malicious Host header can trick the front-end into routing the request to an internal, unintended system.73  
* **Bypassing Authentication:** Some applications restrict access to administrative functionality based on the Host header (e.g., only allowing access from localhost). An attacker can bypass this by simply setting Host: localhost.73

Vulnerabilities can also be exploited via other headers that can override the Host header, such as X-Forwarded-Host.73

**Detection Methods**

* **Manual Detection:**  
  1. **Supply an Arbitrary Host:** Use a tool like Burp Repeater to change the Host header to an arbitrary domain and observe the response. If the application still processes the request and reflects the malicious host in the response body or in a redirect Location header, it may be vulnerable.73  
  2. **Inject Host Override Headers:** Even if the Host header itself is validated, test for override headers like X-Forwarded-Host. Send a request with a legitimate Host header and an X-Forwarded-Host header pointing to a malicious domain.73  
  3. **Send Ambiguous Requests:** Create requests that might be parsed differently by front-end and back-end systems. This includes using duplicate Host headers or supplying an absolute URL in the request line.73  
  4. **Test for SSRF:** Provide a Burp Collaborator domain in the Host or X-Forwarded-Host header and check for any out-of-band network interactions.76  
* **Automated Detection:**  
  1. **DAST Scanners:** Burp Scanner can test for some forms of Host header vulnerabilities, particularly those that result in reflected output or SSRF.  
  2. **Specialized Extensions:** The "Host Header Inchecktion" Burp extension is designed to actively test for multiple types of host header injection, including those leading to SSRF and cache poisoning.76

#### **3.4 HTTP Request Smuggling**

**Summary**

HTTP request smuggling is a technique for interfering with the processing of HTTP requests between a front-end server (like a load balancer or reverse proxy) and a back-end server.77 The vulnerability arises when the front-end and back-end servers disagree on how to determine the boundary of an HTTP request, typically due to ambiguous use of both the

Content-Length (CL) and Transfer-Encoding: chunked (TE) headers in a single request.77

This discrepancy allows an attacker to craft a single request that the front-end server sees as one request but the back-end server interprets as two. The second, "smuggled" request is prepended to the next legitimate user's request that arrives on the same back-end connection, leading to a variety of attacks.77

The three main forms of the vulnerability are:

* **CL.TE:** The front-end server uses the Content-Length header, and the back-end server uses the Transfer-Encoding header.  
* **TE.CL:** The front-end server uses Transfer-Encoding, and the back-end uses Content-Length.  
* **TE.TE:** Both servers support Transfer-Encoding, but one can be induced to ignore it through obfuscation of the header.

Successful exploitation can lead to bypassing security controls, session hijacking, web cache poisoning, and capturing other users' requests.77

**Detection Methods**

Detecting request smuggling is complex and often requires sending requests that may desynchronize the connection, potentially impacting other users. It should be done with care.

* **Manual Detection (Timing-based):**  
  1. **CL.TE Detection:** Send a request where the Content-Length is larger than the body, and the body contains a chunked request that is designed to make the back-end server wait for more data. If the front-end uses CL, it will forward the partial request. If the back-end uses TE, it will process the first chunk and wait for the next, causing a time delay.  
  2. **TE.CL Detection:** Send a request with a malformed chunked message. If the front-end uses TE, it will forward the request. If the back-end uses CL, it will reject the request, often closing the connection and resulting in a different response or a timeout.  
  3. These timing techniques can confirm a desynchronization vulnerability without affecting other users.  
* **Manual Detection (Differential Response):**  
  1. Once a desync is suspected, send a smuggling request that prefixes the next request with a fragment like GPOST /not-a-real-page HTTP/1.1.  
  2. Immediately send a normal request to the site.  
  3. If the normal request receives a 404 Not Found response, it confirms that the smuggled prefix was successfully prepended to it.78  
* **Automated Detection:**  
  1. **Specialized Tools:** Burp Suite's "HTTP Request Smuggler" extension can automate the detection process by sending timing-based probes for CL.TE and TE.CL vulnerabilities and analyzing the responses for evidence of desynchronization.78  
  2. **DAST Scanners:** Some advanced DAST tools have modules for detecting request smuggling, but due to the delicate nature of the tests, manual verification is often required.

### **Section 4: Client-Side and Data Handling Vulnerabilities**

This section covers vulnerabilities that primarily manifest on the client-side or arise from insecure handling of data structures and application logic. These flaws often exploit the user's browser or manipulate the application's state in unexpected ways.

#### **4.1 Cross-Origin Resource Sharing (CORS)**

**Summary**

Cross-Origin Resource Sharing (CORS) is a browser security mechanism that allows a web page from one origin (domain, protocol, port) to request resources from another origin, relaxing the Same-Origin Policy (SOP).79 The SOP is a fundamental security control that prevents scripts on one page from accessing data on another. CORS provides a controlled way to bypass this restriction using a set of HTTP headers, most notably

Access-Control-Allow-Origin (ACAO).79

CORS vulnerabilities arise from misconfigurations that are overly permissive, allowing malicious websites to make cross-origin requests and read sensitive data from a vulnerable application on behalf of a user.80 Common misconfigurations include:

* **Reflecting Arbitrary Origins:** The server dynamically reflects the value of the request's Origin header into the Access-Control-Allow-Origin response header. This effectively allows any website to access the resource.80  
* **Weak Whitelist Validation:** The server uses a flawed regular expression or substring match to validate the Origin header, which can be bypassed by an attacker registering a similar-looking domain (e.g., portswigger.net.attacker.com bypassing a check for portswigger.net).80  
* **Trusting the null Origin:** The server whitelists the null origin, which can be generated by sandboxed iframes or local HTML files, allowing an attacker to exploit the policy.80  
* **Allowing Credentials with Wildcard Origin:** While browsers block JavaScript from reading a response where Access-Control-Allow-Origin: \* is combined with Access-Control-Allow-Credentials: true, a server that dynamically reflects origins can create the same effect, allowing a malicious site to make credentialed requests and steal user-specific data.79

**Detection Methods**

* **Manual Detection:**  
  1. **Identify CORS Headers:** Send a request to the target application from a different origin (e.g., using Burp Repeater and adding an Origin header). Observe the response for CORS headers like Access-Control-Allow-Origin.  
  2. **Test Origin Reflection:** Set the Origin header to an arbitrary domain (e.g., https://evil-user.net) and see if the server reflects it in the Access-Control-Allow-Origin response header.79  
  3. **Probe Whitelist Logic:** If the server appears to use a whitelist, test for bypasses by crafting origins that might match a weak regex or prefix/suffix check (e.g., whitelisted-domain.com.attacker.com, attacker.com/whitelisted-domain.com).  
  4. **Test the null Origin:** Send a request with Origin: null and check if it is accepted in the ACAO response header.80  
* **Automated Detection:**  
  1. **DAST Scanners:** Burp Scanner and other tools can automatically detect common CORS misconfigurations, such as trusting arbitrary origins or the null origin.81

#### **4.2 Clickjacking**

**Summary**

Clickjacking, also known as a UI Redress Attack, is a malicious technique where an attacker uses transparent or opaque layers to trick a user into clicking on a button or link on a different page than they intended.83 The attacker loads the vulnerable target page in a transparent

iframe and overlays it on top of their own decoy page. The user sees the decoy page (e.g., a button that says "Click here to win a prize") but their clicks are passed through to the invisible elements on the target page.83

If the victim is authenticated to the target site, this can be used to trick them into performing sensitive actions, such as transferring money, deleting data, or liking a social media page, without their knowledge.83

**Detection Methods**

Detecting clickjacking is straightforward: it involves checking if a web page can be loaded inside an iframe.

* **Manual Detection:**  
  1. Create a simple HTML page with an iframe whose src attribute points to a sensitive page on the target application.  
  2. Open this HTML file in a browser. If the target page renders successfully inside the iframe, it is vulnerable.84  
* **Automated Detection:**  
  1. **DAST Scanners:** Automated scanners can detect clickjacking by checking for the absence of anti-clickjacking headers (X-Frame-Options or Content-Security-Policy: frame-ancestors) on pages that handle sensitive actions.

#### **4.3 DOM-based Vulnerabilities**

**Summary**

DOM-based vulnerabilities arise when client-side JavaScript takes data from an attacker-controllable source and passes it to a dangerous function, known as a sink, within the same page.86 Unlike traditional reflected or stored vulnerabilities where the server is responsible for embedding the payload in the page, DOM-based vulnerabilities occur entirely within the browser's Document Object Model (DOM).

The flow is from a **source** (an object or property that an attacker can control, like location.hash or document.referrer) to a **sink** (a function or property that can cause a dangerous effect if it processes malicious data, like eval() or element.innerHTML).86

The most well-known DOM-based vulnerability is **DOM-based XSS**, where the source is written to a sink that allows script execution. However, many other vulnerabilities can be DOM-based, including:

* **Open Redirection:** A source like location.search is passed to a sink like window.location.  
* **Cookie Manipulation:** A source is written to the document.cookie sink.  
* **JavaScript Injection:** A source is passed to eval() or setTimeout().  
* **DOM Clobbering:** An advanced technique where an attacker uses HTML injection (e.g., \<a id=some\_variable\>) to create global JavaScript variables in the DOM, which can then overwrite legitimate variables in the application's code, leading to logic flaws or XSS.86

**Detection Methods**

Detecting DOM-based vulnerabilities requires analyzing the client-side JavaScript code to trace the flow of data from sources to sinks.

* **Manual Detection:**  
  1. **Static Analysis:** Manually review the application's JavaScript files to identify all sources and sinks. Trace the data flow between them to see if any attacker-controllable data can reach a dangerous sink without proper sanitization.  
  2. **Dynamic Analysis:** Use browser developer tools to interact with the application. Place a unique string into potential sources (like the URL fragment \#) and use the DOM search functionality to see where it appears. Set breakpoints in the JavaScript code to observe how the data is handled as it flows towards potential sinks.25  
* **Automated Detection:**  
  1. **DAST Scanners:** Modern DAST tools like Burp Scanner have capabilities for analyzing JavaScript. They combine static analysis (parsing the code) and dynamic analysis (executing the code in a headless browser) to identify source-to-sink data flows that indicate a DOM-based vulnerability.25  
  2. **Specialized Tools:** Burp Suite's DOM Invader is a powerful tool specifically designed for testing DOM-based vulnerabilities. It instruments the browser to automatically find sources and test them by sending canary values, then scans for gadgets that can be used to reach dangerous sinks.87

#### **4.4 WebSockets**

**Summary**

WebSockets provide a persistent, full-duplex communication channel over a single TCP connection, initiated via an HTTP handshake.88 While they offer performance benefits over traditional HTTP, they also introduce unique security challenges. Vulnerabilities can exist in the initial handshake or in the ongoing message-based communication.89

Common WebSocket vulnerabilities include:

* **Unsecured Handshake (Cross-Site WebSocket Hijacking \- CSWH):** The WebSocket handshake is a standard HTTP request. If it relies solely on cookies for session handling and lacks CSRF protection, an attacker can perform a CSWH attack. They can trick a victim's browser into initiating a WebSocket connection from a malicious site. The browser will automatically include the victim's session cookies, authenticating the connection to the attacker, who can then send and receive messages on behalf of the victim.88 The  
  Origin header should be validated to prevent this.  
* **Input-based Vulnerabilities (XSS, SQLi):** Data sent over WebSocket messages can be a vector for classic vulnerabilities. If the server receives a message and processes its contents unsafely (e.g., reflecting it in a response to other users without encoding, or using it in a database query), it can lead to Stored XSS or SQL injection.90  
* **Unencrypted Communication:** Using the ws:// protocol instead of the secure wss:// protocol transmits all data in plaintext, making it vulnerable to man-in-the-middle attacks.88  
* **Denial of Service:** If the server does not impose limits on the number of connections or the size of messages, it can be vulnerable to resource exhaustion DoS attacks.88

**Detection Methods**

* **Manual Detection:**  
  1. **Intercepting Communication:** Use a tool like Burp Proxy to view the WebSocket handshake and subsequent messages in the "WebSockets history" tab.91  
  2. **Testing the Handshake:** Check the handshake request for CSRF tokens. If none are present, attempt a CSWH attack by creating a proof-of-concept HTML page that initiates a WebSocket connection to the target endpoint. Also, check if the server validates the Origin header by modifying it in Burp Repeater.90  
  3. **Fuzzing Messages:** Use Burp Repeater to intercept, modify, and replay individual WebSocket messages. Send payloads for common vulnerabilities like XSS and SQLi in message parameters and observe the application's behavior.91  
  4. **Check for wss://:** Ensure the secure protocol is used for all WebSocket connections.  
* **Automated Detection:**  
  1. **DAST Scanners:** Some scanners can identify basic WebSocket vulnerabilities, such as unencrypted connections or missing CSRF protection in the handshake. However, detecting vulnerabilities within the custom logic of WebSocket messages often requires manual testing.

#### **4.5 Insecure Deserialization**

**Summary**

Serialization is the process of converting an object into a format (like a byte stream or a string) that can be stored or transmitted. Deserialization is the reverse process of restoring this data back into an object.93 Insecure deserialization occurs when an application deserializes user-controllable data without sufficient validation.93

This is a highly dangerous vulnerability because the deserialization process itself can trigger malicious code execution before the application logic has a chance to interact with the created object.93 An attacker can craft a malicious serialized object that, when deserialized, leverages existing code within the application or its libraries (known as "gadget chains") to perform unintended actions.95

The impact of insecure deserialization is often critical, leading to:

* **Remote Code Execution (RCE):** The most severe outcome, where an attacker can execute arbitrary commands on the server.95  
* **Privilege Escalation & Authentication Bypass:** An attacker might modify the attributes of a serialized user object to change their role to administrator or bypass security checks.96  
* **Denial of Service:** A malicious object can cause the application to enter an infinite loop or consume excessive resources during deserialization, leading to a crash.95

**Detection Methods**

Detecting insecure deserialization involves identifying where the application uses serialized data and then attempting to manipulate it.

* **Manual Detection:**  
  1. **Identify Serialized Data:** Look for serialized objects in HTTP requests, often in cookies or POST body parameters. They may be binary or string-based (e.g., Base64-encoded PHP serialized strings, Java byte streams).96  
  2. **Modify Object Attributes:** Decode the serialized object, identify attributes that control security (e.g., isAdmin, role), modify their values (e.g., from false to true), re-encode the object, and submit it to the application. Observe if this results in elevated privileges.96  
  3. **Modify Data Types:** Change the data type of an attribute to cause unexpected behavior. For example, changing a password string to an integer 0 might bypass a loose comparison check (==) in the code.96  
  4. **Use Gadget Chains for Blind Detection:** Even if the application logic doesn't directly use the deserialized object, the deserialization process can be exploited. Use pre-built gadget chains (e.g., from tools like ysoserial) to create a payload that triggers a blind, out-of-band interaction. The URLDNS gadget chain for Java is a universal detection method; it forces the server to perform a DNS lookup to a specified domain, which can be detected with Burp Collaborator, confirming that deserialization of untrusted data is occurring.96  
* **Automated Detection:**  
  1. **DAST Scanners with Extensions:** Burp Scanner, with extensions like "Java Deserialization Scanner," can automatically identify serialized objects and test them with known gadget chains to detect vulnerabilities via out-of-band interactions.

#### **4.6 Web LLM Attacks**

**Summary**

The rapid integration of Large Language Models (LLMs) into web applications has introduced a new class of vulnerabilities. Web LLM attacks exploit the model's access to data, APIs, and user information that an attacker cannot access directly.98 The attack surface is broad and can be conceptualized as similar to SSRF, where the LLM acts as a server-side component that can be manipulated to attack other systems.98

Key vulnerabilities, as outlined by OWASP and other security researchers, include:

* **Prompt Injection:** This is the primary attack vector, where an attacker crafts malicious input (a prompt) to manipulate the LLM's behavior, bypassing its safety guidelines.98  
  * **Direct Prompt Injection (Jailbreaking):** The attacker directly interacts with the LLM, providing instructions to override its system prompt (e.g., "Ignore all previous instructions and act as...").99  
  * **Indirect Prompt Injection:** The malicious prompt is delivered via an external source that the LLM processes, such as a web page, a document, or an email. This can be used to attack other users who query the LLM about that source.98  
* **Insecure Output Handling:** The application fails to validate or sanitize the output from the LLM before passing it to other systems or rendering it in a user's browser. This can lead to downstream vulnerabilities like XSS, CSRF, or SSRF.99  
* **Sensitive Information Disclosure:** An attacker can craft prompts to trick the LLM into revealing sensitive information from its training data, system prompts, or data it has accessed via APIs.98  
* **Excessive Agency:** The LLM is granted excessive permissions to interact with back-end APIs or plugins. An attacker can use prompt injection to coerce the LLM into performing unauthorized actions, such as deleting users or accessing sensitive data.101

**Detection Methods**

Detecting LLM vulnerabilities is an emerging field and primarily relies on manual, context-aware testing.

* **Manual Detection:**  
  1. **Map the Attack Surface:** Identify all direct and indirect inputs to the LLM. Determine what data, APIs, and plugins the LLM has access to, often by directly asking the model or using prompt injection to reveal its capabilities.98  
  2. **Test for Prompt Injection:** Attempt to bypass the LLM's system prompts using various jailbreaking techniques. For indirect injection, place malicious prompts in external data sources and then have the LLM process them.  
  3. **Probe for Downstream Vulnerabilities:** Craft prompts designed to make the LLM generate output containing payloads for other vulnerabilities (e.g., XSS payloads like \<img src=1 onerror=alert(1)\>). Check if the application renders this output unsafely.99  
  4. **Test for Data Exfiltration:** Use prompts designed to coax the LLM into revealing parts of its training data or system instructions.98  
* **Automated Detection:**  
  1. Automated detection of complex LLM vulnerabilities is still in its infancy. While traditional DAST scanners can detect the downstream effects (like XSS), they are generally not equipped to understand the nuances of prompt injection. Specialized LLM security testing tools are beginning to emerge.

### **Section 5: API and Caching Vulnerabilities**

This section addresses vulnerabilities specific to modern application architectures, including APIs and complex caching mechanisms. These flaws often arise from design weaknesses, implementation errors, or a misunderstanding of how different technologies interact at scale.

#### **5.1 GraphQL API Vulnerabilities**

**Summary**

GraphQL is a query language for APIs that provides a more efficient and flexible alternative to REST. Unlike REST, which uses multiple endpoints for different resources, GraphQL typically exposes a single endpoint (e.g., /graphql) and allows the client to specify exactly what data it needs in a single request.102

While this offers benefits, it also introduces unique security challenges:

* **Excessive Information Disclosure:** Because clients can query for any data defined in the schema, introspection queries (which reveal the entire API schema) can provide attackers with a complete map of the API's capabilities if not disabled in production.  
* **Denial of Service:** Deeply nested or complex queries can consume excessive server resources, leading to a DoS. An attacker can craft a query that requests a resource and its related resources recursively to a great depth.  
* **Broken Access Control:** Access control in GraphQL can be more complex than in REST. Authorization checks must be implemented at the level of individual fields within the schema (in the "resolver" functions). If a developer forgets to apply an authorization check to a sensitive field, an attacker may be able to access it simply by including it in their query.  
* **Injection Flaws:** GraphQL APIs are still susceptible to traditional injection attacks like SQLi or NoSQLi if the resolver functions that fetch data from a database do so by insecurely constructing queries from user-supplied arguments.

**Detection Methods**

* **Manual Detection:**  
  1. **Introspection:** Send a standard introspection query to the GraphQL endpoint. If it returns the schema, the attacker has a full roadmap for further attacks. Tools like Burp Suite can automatically parse this schema and add it to its site map.  
  2. **Test for Authorization Flaws:** Authenticate as different users (or as an unauthenticated user) and attempt to query for fields that should be restricted. For example, a standard user should not be able to query for a user object and include the passwordHash field.  
  3. **Test for DoS:** Use tools to craft deeply nested or circular queries and observe the server's response time and resource consumption.  
  4. **Test for Injection:** Treat all query arguments as untrusted user input and test for classic injection vulnerabilities like SQLi by providing malicious values in the arguments.  
* **Automated Detection:**  
  1. **DAST Scanners:** Scanners are increasingly adding support for GraphQL. Burp Suite Professional can parse GraphQL requests, identify queries and mutations, and perform scans on the arguments within them.103

#### **5.2 API Testing**

**Summary**

API (Application Programming Interface) security testing is a broad discipline focused on identifying and mitigating vulnerabilities in APIs, which form the backbone of modern web and mobile applications.104 Unlike traditional web applications, APIs often expose raw application logic and data access, making them a prime target for attackers.

A structured approach to API security testing involves several key steps 105:

1. **Understanding Endpoints:** The first step is to map the entire API attack surface by identifying all endpoints, their supported HTTP methods, parameters, and expected request/response formats. This often involves analyzing documentation (like OpenAPI/Swagger specifications) and observing traffic.105  
2. **Authentication and Authorization Testing:** This is critical for APIs. It involves testing for broken authentication (e.g., weak API keys, flawed JWT validation) and broken authorization, particularly Broken Object Level Authorization (BOLA), where an attacker can access data belonging to other users by manipulating object IDs in API requests.105  
3. **Input Validation and Data Integrity:** Testing for classic injection vulnerabilities (SQLi, NoSQLi, Command Injection, XSS) within API parameters and request bodies.105  
4. **Business Logic and Rate Limiting:** Testing for flaws in the API's business logic and checking for missing or ineffective rate limiting, which can lead to DoS or brute-force attacks.  
5. **Mass Assignment:** Testing if an attacker can modify object properties they should not have access to by providing extra fields in a JSON request body.  
6. **Excessive Data Exposure:** Checking if API endpoints return more data than is necessary for the client application's function, potentially exposing sensitive information.

**Detection Methods**

API testing combines manual and automated techniques, often using a proxy like Burp Suite to intercept and modify API requests.

* **Manual Detection:**  
  * **Documentation Review:** Start by reviewing any available API documentation to understand the intended functionality of each endpoint.  
  * **Proxy Traffic:** Use Burp Suite to capture and analyze traffic from the client application (web or mobile) to identify all API endpoints being used.  
  * **Authorization Testing:** This is a primary focus. For every endpoint that takes an object ID, change the ID to one belonging to another user and check if the request is successful (testing for BOLA/IDOR).  
  * **Fuzzing:** Use Burp Intruder to fuzz all parameters and JSON fields with payloads for various vulnerability classes.  
* **Automated Detection:**  
  * **DAST Scanners:** Burp Scanner can perform automated scans of APIs. It can ingest API definitions (like OpenAPI) to guide its scanning process, making it highly effective at finding many common API vulnerabilities.

#### **5.3 Web Cache Poisoning**

**Summary**

Web cache poisoning is an advanced attack where an attacker exploits the behavior of a web server and cache to serve a harmful HTTP response to other users.106 The attack has two phases: first, the attacker elicits a malicious response from the back-end server; second, they ensure this response gets stored in the cache.106 When other users request the same resource, the cache serves the poisoned content.

The vulnerability hinges on the concept of the **cache key**. Caches store and retrieve responses based on a key generated from certain parts of an HTTP request (typically the request line and Host header). Other parts of the request, such as most HTTP headers, are often **unkeyed**, meaning the cache ignores them.107 An attacker can exploit this by sending a request with a legitimate cache key but including a malicious payload in an unkeyed header. If the server's response is influenced by this unkeyed header, a poisoned response can be cached under the legitimate key.106

The impact is severe, as it can turn a reflected vulnerability (like XSS) into a stored one, affecting every user who visits a popular page.106

**Detection Methods**

Detecting web cache poisoning requires identifying unkeyed inputs that affect the application's response.

* **Manual Detection:**  
  1. **Identify Unkeyed Inputs:** This is the most critical step. Manually add various non-standard HTTP headers (e.g., X-Forwarded-Host, X-Forwarded-Scheme) to a request and observe if they change the response. This is a tedious process.  
  2. **Elicit a Harmful Response:** Once an unkeyed input is found to affect the response (e.g., it's reflected in the page or used to build a URL), attempt to inject a payload.  
  3. **Get the Response Cached:** Send the malicious request and then, from a different browser or IP, request the same URL without the malicious header. If the poisoned response is served, the cache is vulnerable. Identifying a "cache oracle" (e.g., a response header like X-Cache: hit/miss or a noticeable time difference) is crucial for this step.108  
* **Automated Detection:**  
  1. **Param Miner:** This Burp Suite extension is the industry-standard tool for detecting web cache poisoning. It automates the process of finding unkeyed inputs by sending requests with a large dictionary of potential headers and analyzing the responses for any changes.106

#### **5.4 Web Cache Deception**

**Summary**

Web cache deception is an attack where an attacker tricks a web cache into erroneously storing sensitive, user-specific content under a public, cacheable URL.109 The attacker can then access this cached content to steal the victim's private information.110

The attack exploits discrepancies in how a cache and a back-end server parse URLs.109 The core of the attack is to craft a URL that the cache believes is for a static, cacheable asset (like a CSS or JS file), but the back-end server interprets as a request for a dynamic, sensitive page (like a user's profile).

For example, an attacker might lure a victim to a URL like https://vulnerable-site.com/account/profile.css.

* The **cache** sees the .css extension and, based on its rules, decides the response is cacheable.  
* The back-end application, however, might have a routing rule that ignores the file extension and serves the content for /account/profile.  
  The result is that the victim's private profile page is cached publicly at the /account/profile.css URL, which the attacker can then visit to retrieve the sensitive data.112

**Detection Methods**

* **Manual Detection:**  
  1. **Identify Sensitive Endpoints:** Find pages that return user-specific, sensitive information.  
  2. **Craft Deceptive URLs:** Append a fake static file extension to the URL path of the sensitive endpoint (e.g., /profile/nonexistent.js).  
  3. **Check for Caching:** Send the request while authenticated as a victim. Check response headers for cache indicators (X-Cache, Age, etc.). Then, send the same request from an unauthenticated session. If the sensitive content is returned, the application is vulnerable.109  
  4. **Test for Parser Discrepancies:** Experiment with different path structures, delimiters, and URL-encoded characters to find parsing inconsistencies between the cache and the back-end.109  
* **Automated Detection:**  
  1. **DAST Scanners:** Some scanners can test for web cache deception by automatically appending static extensions to discovered URLs and checking for signs of caching sensitive content.

### **Section 6: Advanced and Miscellaneous Vulnerabilities**

This final section covers a diverse set of vulnerabilities that arise from complex application states, flawed data handling, and insecure implementation of modern web technologies.

#### **6.1 Race Conditions**

**Summary**

A race condition is a vulnerability that occurs when the security or logic of an application depends on the timing of events, and an attacker can influence this timing to their advantage. These flaws arise in multi-threaded applications where multiple processes or threads access and manipulate the same shared resource (like a user's account balance or a session variable) concurrently, without proper synchronization.

A common example is a **limit-overrun** race condition. Consider an online store that allows a user to apply a single-use discount code. The logic might be:

1. Check if the user has already used the code.  
2. If not, apply the discount and update the database to mark the code as used.

An attacker could exploit this by sending two requests to apply the code in rapid succession. If both requests execute step 1 before either has completed step 2, the application will believe the code is valid for both requests, allowing the attacker to use the discount twice.

Other examples include exploiting race conditions in multi-step processes (like password changes) or causing Time-of-Check to Time-of-Use (TOCTOU) flaws.

**Detection Methods**

Detecting race conditions is notoriously difficult for automated scanners and often requires manual, targeted testing.

* **Manual Detection:**  
  1. **Identify Target Functionality:** Look for functions that involve a multi-step process with a shared resource, especially those with a limit (e.g., applying a coupon, voting, transferring funds).  
  2. **Simultaneous Requests:** Use a tool like Burp Intruder's "pitchfork" attack type or Turbo Intruder to send multiple, near-simultaneous requests that trigger the target function.  
  3. **Observe the Outcome:** Analyze the application's state after the attack to see if the limit was successfully bypassed. This may require checking an account balance, a profile setting, or the number of items in an inventory.  
* **Automated Detection:**  
  1. While general-purpose scanners struggle, specialized tools and Burp Suite extensions like Turbo Intruder are designed specifically for sending high-speed, parallel requests needed to test for race conditions.

#### **6.2 File Upload Vulnerabilities**

**Summary**

File upload vulnerabilities occur when a server allows users to upload files without sufficiently validating their name, type, contents, or size.114 This can be a high-severity risk, as it may allow an attacker to upload a

**web shell**—a script that executes commands on the server—leading to complete system takeover.114

Vulnerabilities arise from flawed validation logic, such as:

* **Insufficient File Type Validation:** Relying only on the Content-Type header, which is user-controllable, or using a blacklist of dangerous extensions (.php, .jsp) that can be bypassed with alternative extensions (.phtml, .php5) or obfuscation techniques.114  
* **Flawed Filename Handling:** Allowing directory traversal sequences (../) in the filename or failing to prevent overwriting critical system files.114  
* **Race Conditions:** A temporary window between when a file is uploaded and when it is validated and removed can be exploited to execute the file.114  
* **Content Validation Bypass:** Bypassing checks for file content (e.g., "magic bytes") by embedding a payload within a seemingly valid file, such as in the metadata of a JPEG image (a polyglot file).114

**Detection Methods**

* **Manual Detection:**  
  1. **Bypass Extension Filters:** Attempt to upload a file with various executable extensions. If a blacklist is in use, try alternative extensions, case variations (.pHp), multiple extensions (shell.php.jpg), trailing characters (shell.php.), or null byte injection (shell.php%00.jpg).114  
  2. **Test Content-Type Validation:** Upload a malicious script but change the Content-Type header to an allowed type, like image/jpeg.  
  3. **Test Content Validation:** Use tools to create polyglot files that are valid images but also contain executable code, and attempt to upload them.  
  4. **Test for Race Conditions:** Use Burp Intruder to repeatedly upload a web shell and simultaneously send requests to the predicted location of the temporary file to try to execute it before it is deleted.  
* **Automated Detection:**  
  1. **DAST Scanners:** Scanners can test for basic file upload vulnerabilities by attempting to upload files with various extensions and content types. However, bypassing complex validation logic often requires manual testing.

#### **6.3 Business Logic Vulnerabilities**

**Summary**

Business logic vulnerabilities are flaws in the design and implementation of an application's workflow that allow an attacker to elicit unintended behavior.117 Unlike technical vulnerabilities like SQLi, which exploit parsing or interpretation flaws, logic flaws manipulate legitimate application functionality to achieve a malicious goal.117

These flaws are often unique to the application and its business domain and arise from flawed assumptions developers make about how a user will interact with the system.117 Examples include:

* **Workflow Bypass:** An attacker manipulates requests to skip steps in a critical process, such as skipping the payment step in an e-commerce checkout flow.119  
* **Price Manipulation:** An attacker intercepts a request to add an item to a shopping cart and modifies the price parameter to a lower value.  
* **Excessive Trust in Client-Side Controls:** The application relies on client-side JavaScript to enforce rules (e.g., preventing negative quantities), which an attacker can easily bypass by modifying the HTTP request.118  
* **Flawed Assumptions about User Behavior:** An e-commerce site might allow a user to apply a high-value coupon and then add cheaper items to the cart, receiving a disproportionate discount because the logic did not anticipate this sequence of actions.118

**Detection Methods**

Detecting business logic flaws is almost exclusively a manual process, as it requires a deep understanding of the application's intended purpose and business rules. Automated scanners cannot understand context and therefore cannot identify when a workflow is being abused.

* **Manual Detection:**  
  1. **Understand the Application:** The first and most critical step is to thoroughly map the application and understand its business processes, user roles, and the logic behind its workflows.  
  2. **Think Like an Attacker:** Question all assumptions. What happens if I submit a negative value? What if I repeat a step? What if I skip a step?  
  3. **Manipulate All Parameters:** Use a proxy like Burp Suite to intercept every request and tamper with every parameter, including prices, quantities, user IDs, and discount codes, to see if the server-side logic can be manipulated.  
  4. **Test Multi-Stage Processes:** For any process that involves multiple steps, try to access later steps directly by URL, replay requests, or perform steps in an illogical order.

#### **6.4 Information Disclosure**

**Summary**

Information disclosure, or information leakage, is when a website unintentionally reveals sensitive information to users.120 This information can be directly sensitive (e.g., other users' personal data, credit card numbers) or technical (e.g., software versions, internal IP addresses, file paths, database error details).120

While technical information disclosure may not have a direct impact, it is invaluable to an attacker for reconnaissance. Knowing the specific versions of software in use allows an attacker to search for known public exploits. Verbose error messages can reveal database table names, aiding in SQLi attacks. Developer comments left in HTML or source code can reveal hidden functionality or internal logic.120

Vulnerabilities arise from:

* **Verbose Error Messages:** Default configurations of web servers and frameworks often return detailed error messages and stack traces in a production environment.121  
* **Insecure Configuration:** Directory listings being enabled, or backup files (.bak, .swp) and version control directories (.git, .svn) being left in the web root.120  
* **Flawed Application Logic:** Subtle differences in application responses can allow an attacker to infer information, such as whether a username is valid.120

**Detection Methods**

* **Manual Detection:**  
  1. **Trigger Errors:** Intentionally submit malformed input to the application to see if it returns verbose error messages.  
  2. **Source Code Review:** Inspect the HTML source of every page for comments that leak information.  
  3. **File and Directory Discovery:** Use tools like Burp Intruder or directory brute-forcing tools to search for common backup file extensions, version control directories, and configuration files like robots.txt.120  
* **Automated Detection:**  
  1. **DAST Scanners:** Automated scanners are very effective at detecting information disclosure. They can trigger errors, search for comments, and probe for common sensitive files and directories. Burp Scanner has numerous checks for various types of information leakage.

#### **6.5 Prototype Pollution**

**Summary**

Prototype pollution is a JavaScript-specific vulnerability that allows an attacker to add or modify properties of the global Object.prototype.122 In JavaScript, most objects inherit properties from a prototype. By "polluting" the base

Object.prototype, an attacker can inject properties that will then be inherited by almost every object in the application.123

The vulnerability typically arises when a JavaScript library performs a recursive merge of two objects, and an attacker can control one of the source objects. By injecting a property with the key \_\_proto\_\_, the merge operation may be tricked into modifying the prototype of the target object instead of the object itself.122

While often not directly exploitable, prototype pollution is a powerful primitive for chaining attacks. If an application later uses a property that the attacker has injected into the prototype in an unsafe way (a "gadget"), it can lead to vulnerabilities like DOM-based XSS on the client-side or Remote Code Execution on the server-side (Node.js).122

**Detection Methods**

* **Manual Detection (Client-Side):**  
  1. **Identify Potential Sources:** Look for parts of the application where user input (from the URL query string, URL fragment, or JSON messages) is used to construct or merge JavaScript objects.122  
  2. **Inject a Test Property:** Craft an input that attempts to pollute the prototype, such as ?\_\_proto\_\_\[testproperty\]=testvalue.  
  3. **Verify in Console:** Use the browser's developer console to check if the pollution was successful by creating a new empty object (let myObject \= {};) and seeing if it has inherited the test property (console.log(myObject.testproperty);).87  
  4. **Find Gadgets:** Once pollution is confirmed, search the application's client-side code for properties that are read from objects and used in dangerous sinks (e.g., innerHTML, script.src).  
* **Automated Detection (Client-Side):**  
  1. **DOM Invader:** Burp Suite's DOM Invader is the primary tool for detecting client-side prototype pollution. It can automatically identify sources where pollution is possible and then scan the application's code for exploitable gadgets that can be reached via those sources.87  
* **Manual Detection (Server-Side):**  
  1. Detecting server-side prototype pollution is more difficult as the effects are not directly visible. It often involves identifying gadgets in the server-side code (e.g., properties that affect command execution or file paths) and then attempting to pollute them and observe side effects, such as a change in the application's behavior, status code, or response time.123

---

## **Part II: Detection Engineering with the Splunk Web Data Model**

Effective detection of web application attacks requires a centralized and normalized view of web traffic. Simply collecting raw logs from various web servers, proxies, and web application firewalls (WAFs) is insufficient, as each source has a unique format. This is where the Splunk Common Information Model (CIM) provides critical value. The CIM acts as a schema, defining a standard set of fields and tags for different data domains.

### **Section 7: Principles of Web Attack Detection in Splunk**

The **Web Data Model** is a core component of the CIM, designed to normalize data from any source that logs HTTP traffic.124 By mapping vendor-specific field names (e.g., Apache's

| from datamodel=Web.Web

| comment "This eval statement categorizes events into different attack types based on signatures. Add or tune signatures here."
| eval attack_type=case(
    match(url, "(?i)(\'|\"|%27|%22).*(?i)(\b(union|select|insert|update|delete|drop|alter)\b)") OR match(form_data, "(?i)(\'|\"|%27|%22).*(?i)(\b(union|select|insert|update|delete|drop|alter)\b)"), "SQL Injection",
    match(url, "(?i)(\.\./|\.\.%2[fF]|\.\.%5[cC])"), "Path Traversal",
    match(url, "(?i)(;|`|\$|\(|\)|<|>|%0a|%0d).*(?i)(cat|ls|whoami|uname|id|pwd|netstat|ifconfig|ipconfig)"), "Command Injection",
    match(url, "(?i)\.(bak|swp|old|config|sql)$|\b(.git|.svn|/wwwroot/)\b"), "Information Disclosure",
    http_method="POST" AND match(file_name, "(?i)\.(php|jsp|aspx|sh|exe|dll)$"), "Malicious File Upload",
    match(url, "(?i)(127\.0\.0\.1|localhost|169\.254\.169\.254|10\.\d{1,3}\.\d{1,3}\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}|172\.(1[6-9]|2[0-9]|3[0-1])\.\d{1,3}\.\d{1,3})"), "Server-Side Request Forgery (SSRF)",
    http_method="POST" AND match(form_data, "(?i)<!DOCTYPE\s+.*\s+SYSTEM"), "XXE Injection",
    match(url, "(?i)\[(\$ne|\$gt|\$in|\$where)\]") OR match(form_data, "(?i)(\$ne|\$gt|\$in|\$where)"), "NoSQL Injection",
    match(url, "(?i)(<script|%3Cscript|javascript:|onerror=|onload=|onmouseover=)"), "Cross-Site Scripting (XSS)",
    http_method="POST" AND (http_referrer="-" OR (spath(http_referrer, "host")!=host)), "Potential Cross-Site Request Forgery (CSRF)",
    isnotnull(http_header_values) AND mvfilter(match(http_header_values, "(?i)Access-Control-Allow-Origin:\s*\*")), "Insecure CORS Policy",
    isnotnull(http_header_values) AND NOT (mvfilter(match(http_header_values, "(?i)X-Frame-Options")) OR mvfilter(match(http_header_values, "(?i)Content-Security-Policy.*frame-ancestors"))), "Clickjacking (Missing Headers)",
    match(url, "(?i)\.(js|css|png|gif)$") AND isnotnull(http_header_names) AND mvfilter(match(http_header_names, "(?i)X-Forwarded-Host")), "Web Cache Poisoning",
    host != dest, "HTTP Host Header Attack",
    isnotnull(http_header_names) AND mvfilter(match(http_header_names, "(?i)Content-Length")) AND mvfilter(match(http_header_names, "(?i)Transfer-Encoding")), "HTTP Request Smuggling",
    isnotnull(http_header_values) AND match(mvfilter(match(http_header_values, "Authorization: Bearer .*")), "\.eyJhbGciOiJub25lIg"), "JWT Attack (alg:none)",
    1=1, "Not an Attack"
)

| comment "Filter out events that did not match any attack signature."
| where attack_type != "Not an Attack"

| comment "Group the results by attack type, source/destination, user, and the specific URL involved. Count the occurrences."
| stats count, values(user) as users by attack_type, src, dest, url

| comment "Sort the results to show the most frequent potential attacks first."
| sort -count

| comment "Rename fields for better readability in the final report."
| rename src as Source_IP, dest as Destination_IP, url as Target_URL, users as Associated_Users, attack_type as Attack_Type, count as Event_Count


c-ip, IIS's cs-uri-query) to standardized CIM field names (e.g., src, url), security analysts can write a single, powerful detection query that works across their entire environment, regardless of the underlying technology.126 Key fields in the Web Data Model include

src, dest, url, http\_method, status, http\_user\_agent, and url\_length.

A crucial aspect of modern detection engineering, particularly evident in the following queries, is the shift from simple signature matching to heuristic and behavioral analysis. Attackers can easily obfuscate simple attack strings (e.g., URL-encoding the word SELECT). Therefore, robust detections often focus on the *artifacts* or *behaviors* of an attack rather than a specific payload. For example, a complex SQL injection attempt often results in an unusually long URL, and an automated exploit script may use a generic user agent like Python's urllib.127 By combining these weaker but more resilient indicators, detection queries can achieve higher fidelity and are less prone to evasion. This approach, however, necessitates environmental tuning; what constitutes a "long" URL is relative, and analysts must baseline their own traffic to minimize false positives.127

### **Section 8: Master Table of Vulnerability Detection Queries**

The following table provides a set of practical, actionable Splunk queries designed to detect various web application attacks. These queries are written using the Web Data Model and serve as a starting point for threat hunting and alerting within a security operations environment. Each query is accompanied by a brief description of its detection logic.

| Vulnerability | Brief Description of Detection Logic | Splunk Web Data Model SPL Query |
| :---- | :---- | :---- |
| **SQL Injection** | Identifies potential SQLi by flagging web requests with anomalously long URLs or user-agent strings that also contain a high frequency of SQL command keywords. This is a behavioral analytic designed to catch obfuscated or complex injection attempts.127 | | tstats \\security\_content\_summariesonly\` count from datamodel=Web where Web.dest\_category=web\_server AND (Web.url\_length \> 1024 OR Web.http\_user\_agent\_length \> 200\) by Web.src, Web.dest, Web.url, Web.url\_length, Web.http\_user\_agent | \`drop\_dm\_object\_name("Web")\` | eval url=lower(url) | eval num\_sql\_cmds=mvcount(split(url, "alter")) \+ mvcount(split(url, "between")) \+ mvcount(split(url, "create")) \+ mvcount(split(url, "delete")) \+ mvcount(split(url, "drop")) \+ mvcount(split(url, "exec")) \+ mvcount(split(url, "insert")) \+ mvcount(split(url, "select")) \+ mvcount(split(url, "union")) \+ mvcount(split(url, "xp\_cmdshell")) \- 10 | where num\_sql\_cmds \> 3 | \`sql\_injection\_with\_long\_urls\_filter\`\` |
| **Authentication** | Detects brute-force login attempts by counting a high number of failed authentication events (e.g., HTTP status 401 or 403 on a login page) from a single source IP address within a short time window. | | tstats \\security\_content\_summariesonly\` count from datamodel=Web where Web.http\_method=POST AND Web.url IN ("/login", "/auth", "/signin") AND Web.status IN (401, 403\) by Web.src, Web.url | where count \> 20 | \`brute\_force\_login\_attempts\_filter\`\` |
| **Path Traversal** | Searches for common and encoded path traversal sequences (../, ..%2f, ..%5c, etc.) within the URL field of web requests. | | tstats \\security\_content\_summariesonly\` count from datamodel=Web where Web.url="*../*" OR Web.url="*..%2f*" OR Web.url="*..%5c*" OR Web.url="*..%c0%af*" by Web.src, Web.dest, Web.url | \`drop\_dm\_object\_name("Web")\` | \`path\_traversal\_filter\`\` |
| **Command Injection** | Identifies web requests where the URL or form data contains common OS commands following shell metacharacters. This query is signature-based and should be tuned for specific environments to reduce false positives. | \`from datamodel=Web | search (url="*\&whoami*" OR url="*;whoami*" OR url="\* |
| **Business Logic** | Detects potential price tampering by identifying requests where a price-related parameter has an unusually low or negative value. This requires baselining normal price ranges. | from datamodel=Web | search (form\_data="\*price=-\*" OR form\_data="\*price=0\*" OR form\_data="\*amount=-\*" OR form\_data="\*amount=0\*") | table \_time, src, dest, url, form\_data, user | \\price\_tampering\_filter\`\` |
| **Information Disclosure** | Searches for common backup file extensions or version control directory names in the URL, which could indicate sensitive source code or configuration file exposure. | from datamodel=Web | search (url="\*.bak" OR url="\*.swp" OR url="\*.old" OR url="\*/.git/\*" OR url="\*/.svn/\*") | table \_time, src, dest, url | \\info\_disclosure\_backup\_files\_filter\`\` |
| **Access Control (IDOR)** | Identifies potential horizontal privilege escalation by flagging users who access an abnormally high number of unique resources (e.g., different account IDs) in a short time, suggesting enumeration. | from datamodel=Web | rex field=url "/api/accounts/(?\<account\_id\>\\d+)" | bucket \_time span=5m | stats dc(account\_id) as unique\_accounts by src, user, \_time | where unique\_accounts \> 50 | \\idor\_enumeration\_filter\`\` |
| **File Upload** | Detects attempts to upload potentially malicious files by looking for suspicious file extensions (e.g., .php, .jsp, .aspx) in the filename of a POST request, often seen in form\_data. | from datamodel=Web | search http\_method=POST AND (form\_data="\*filename=\\\\"\*.php\\\\"" OR form\_data="\*filename=\\\\"\*.jsp\\\\"" OR form\_data="\*filename=\\\\"\*.aspx\\\\"") | table \_time, src, dest, url, form\_data, user | \\malicious\_file\_upload\_filter\`\` |
| **SSRF** | Detects potential SSRF attempts by searching for web requests where URL parameters contain common internal hostnames, private IP addresses, or cloud metadata endpoints.128 | from datamodel=Web | search (url="\*localhost\*" OR url="\*127.0.0.1\*" OR url="\*169.254.169.254\*" OR url="\*10.0.0.0/8\*" OR url="\*172.16.0.0/12\*" OR url="\*192.168.0.0/16\*") | rex field=url "(?\<param\_value\>https?://\[^/\]+)" | table \_time, src, dest, url, param\_value | \\ssrf\_attempt\_filter\`\` |
| **XXE Injection** | Searches the HTTP POST body for XML declarations that include DOCTYPE and SYSTEM keywords, which are indicative of an attempt to declare an external entity. Requires logs that capture the full POST body. | from datamodel=Web | search http\_method=POST AND form\_data="\*\<\!DOCTYPE\*" AND form\_data="\*SYSTEM\*" | table \_time, src, dest, url, form\_data | \\xxe\_injection\_filter\`\` |
| **NoSQL Injection** | Identifies potential NoSQL operator injection by searching for URL parameters or form data containing common NoSQL operators like $ne, $gt, $in, or $where. | from datamodel=Web | search (url="\*\[$ne\]\*" OR url="\*\[$gt\]\*" OR url="\*\[$in\]\*" OR url="\*\[$where\]\*" OR form\_data="\*\[$ne\]\*" OR form\_data="\*\[$gt\]\*" OR form\_data="\*\[$in\]\*" OR form\_data="\*\[$where\]\*") | table \_time, src, dest, url, form\_data | \\nosql\_injection\_filter\`\` |
| **XSS** | Detects common reflected XSS attempts by searching for HTML script tags and event handlers in the URL query string. This is a basic signature and prone to evasion but serves as a starting point. | from datamodel=Web | search (url="\*\<script\>\*" OR url="\*onerror=\*" OR url="\*onload=\*" OR url="\*javascript:\*") | table \_time, src, dest, url, user | \\reflected\_xss\_filter\`\` |
| **CSRF** | Detects potential CSRF attacks by identifying a high volume of state-changing POST requests that are missing a Referer header or have a Referer from a different domain than the target host. | from datamodel=Web | where http\_method="POST" AND (Referer=null OR NOT match(Referer, "https?://".dest)) | stats count by src, dest, Referer, user | where count \> 10 | \\csrf\_suspicious\_referer\_filter\`\` |
| **CORS Misconfiguration** | Identifies overly permissive CORS policies by searching for responses where the Access-Control-Allow-Origin header is set to the wildcard \* or reflects the Origin header value when credentials are also allowed. | from datamodel=Web | search (http\_header="Access-Control-Allow-Origin: \*" OR (http\_header="Access-Control-Allow-Credentials: true" AND match(http\_header, "Access-Control-Allow-Origin: https?://.\*"))) | table \_time, src, dest, url, http\_header | \\cors\_misconfiguration\_filter\`\` |
| **Clickjacking** | This is best detected by checking for the *absence* of anti-clickjacking headers. This query finds responses that are missing X-Frame-Options or a Content-Security-Policy with frame-ancestors. | from datamodel=Web | search http\_content\_type="text/html" | where NOT (match(http\_header, "X-Frame-Options") OR match(http\_header, "Content-Security-Policy:.\*frame-ancestors")) | stats count by dest, url | \\clickjacking\_header\_missing\_filter\`\` |
| **Web Cache Poisoning** | Detects potential cache poisoning by identifying requests that contain both a cacheable file extension (e.g., .js, .css) and a non-standard Host-override header like X-Forwarded-Host. | from datamodel=Web | where (match(url, "\\.js$") OR match(url, "\\.css$")) AND isnotnull(X\_Forwarded\_Host) | table \_time, src, dest, url, X\_Forwarded\_Host, user | \\cache\_poisoning\_header\_filter\`\` |
| **HTTP Host Header Attacks** | Identifies requests where the Host header does not match the destination server, potentially indicating a bypass or routing attack. Requires a lookup of valid hostnames. | from datamodel=Web | lookup valid\_hostnames dest AS dest OUTPUT is\_valid | where is\_valid IS NULL AND NOT match(Host, dest) | table \_time, src, dest, Host, url | \\host\_header\_mismatch\_filter\`\` |
| **HTTP Request Smuggling** | Detects a key indicator of potential request smuggling by identifying requests that contain both Content-Length and Transfer-Encoding headers, which is ambiguous per RFC 7230\. | from datamodel=Web | where isnotnull(Content\_Length) AND isnotnull(Transfer\_Encoding) | table \_time, src, dest, url, user | \\ambiguous\_request\_smuggling\_filter\`\` |
| **JWT Attacks** | Detects the alg:none attack vector by searching for JWTs in authorization headers where the header part, when decoded, specifies the "none" algorithm. | from datamodel=Web | rex field=http\_header "Authorization:\\s+Bearer\\s+(?\<jwt\_header\>\[^.\]+)\\." | eval decoded\_header=base64decode(jwt\_header) | where match(decoded\_header, "\\"alg\\"\\s\*:\\s\*\\"none\\"") | table \_time, src, dest, url, user, decoded\_header | \\jwt\_alg\_none\_filter\`\` |

---

## **Part III: Essential Competencies for the Modern Web Security Professional**

The preceding analysis of vulnerabilities and detection techniques reveals a clear and demanding set of skills required for professionals in the field of web application security. The modern practitioner can no longer operate in a silo; the convergence of development, operations, and security—often termed DevSecOps—necessitates a multi-disciplinary skill set. The lines between pentester, developer, and SOC analyst are blurring, giving rise to a new ideal of a "T-shaped" professional with broad knowledge across the entire software development lifecycle (SDLC) and deep expertise in specific security domains.130

### **Section 9: The Web Security Skill Matrix**

The essential competencies can be organized into a skill matrix that covers foundational knowledge, offensive capabilities, defensive engineering, and strategic integration into the development process.

* **Technical Foundations:** This is the bedrock upon which all other skills are built. A professional must possess a deep, intuitive understanding of the core technologies that constitute the modern web.  
  * **Networking and Protocols:** Mastery of HTTP/1.1 and HTTP/2, including headers, methods, status codes, and connection handling. A strong grasp of TCP/IP, DNS, and TLS is also fundamental for understanding how data moves and how it can be intercepted or manipulated.132  
  * **Web Architecture:** Knowledge of modern application architectures, including the roles of reverse proxies, load balancers, CDNs, and microservices. Understanding these components is critical for identifying infrastructure-level vulnerabilities like SSRF, Host header attacks, and request smuggling.132  
  * **Operating Systems:** Proficiency with both Linux and Windows command lines and system configurations is necessary for exploiting and defending against command injection and path traversal vulnerabilities.133  
  * **Applied Cryptography:** A practical understanding of cryptographic principles, including hashing, symmetric vs. asymmetric encryption, and digital signatures, is essential for analyzing vulnerabilities in JWTs and TLS configurations.132  
* **Offensive Security Acumen:** The ability to think and act like an attacker is non-negotiable for identifying vulnerabilities before they can be exploited.  
  * **Manual Penetration Testing:** Proficiency in manual testing methodologies is paramount, as many complex vulnerabilities, especially in business logic and access control, cannot be found by automated tools.135 This includes a mastery of intercepting proxies like Burp Suite for request manipulation and analysis.7  
  * **Vulnerability Knowledge:** Deep expertise in the vulnerabilities detailed in this report and frameworks like the OWASP Top 10 is required.130 This goes beyond memorization to an understanding of the root causes and exploitation techniques.  
  * **Scripting and Automation:** Proficiency in a scripting language like Python is crucial for writing custom exploit scripts, automating repetitive testing tasks, and parsing large datasets.133  
* **Defensive and Detection Engineering:** A modern professional must be able to translate offensive knowledge into robust defenses and high-fidelity detections.  
  * **Log Analysis and SIEM:** Expertise in analyzing logs from various sources (web servers, WAFs, operating systems) and using a SIEM platform like Splunk. This includes writing advanced queries, understanding data models like the CIM, and building dashboards and alerts.11  
  * **Threat Modeling:** The ability to analyze an application's design and data flows to proactively identify potential security risks before they are implemented.140  
  * **Defensive Technologies:** A strong understanding of the capabilities and limitations of defensive tools like Web Application Firewalls (WAFs), Runtime Application Self-Protection (RASP), and Intrusion Detection Systems (IDS/IPS).3  
* **Secure Development Lifecycle (SDLC) Integration:** Security can no longer be an afterthought. Professionals must be able to integrate security into every phase of development.  
  * **Secure Coding Practices:** A thorough understanding of secure coding principles, such as input validation, output encoding, parameterized queries, and secure session management. The ability to communicate these principles effectively to developers is key.131  
  * **Code Review:** The skill to perform both manual and automated (SAST) source code reviews to identify vulnerabilities early in the development cycle.  
  * **CI/CD Security:** Knowledge of how to integrate security testing tools (SAST, DAST, SCA) into continuous integration and continuous delivery pipelines to automate security checks.132  
* **Continuous Learning and Adaptability:** The threat landscape evolves constantly. The most critical non-technical skill is a commitment to continuous learning and the ability to adapt to new technologies and attack vectors, such as the emerging threats against Web LLMs and GraphQL APIs.98 This requires relentless curiosity and a passion for breaking things (legally) to understand how they work.141

The convergence of these skill sets is the defining characteristic of the modern web security expert. An effective professional is not just a pentester who finds flaws, a developer who writes code, or an analyst who watches logs. They are a hybrid professional who understands how a vulnerability is introduced in code, how it is exploited by an attacker, and how its artifacts can be detected in logs. This cross-domain expertise is what enables a truly resilient security posture.

#### **Alıntılanan çalışmalar**

1. OWASP Top 10: Injection – What It Is And How To Protect Your Applications | Cyolo, erişim tarihi Ağustos 11, 2025, [https://cyolo.io/blog/owasp-top-10-injection-what-it-is-and-how-to-protect-our-applications](https://cyolo.io/blog/owasp-top-10-injection-what-it-is-and-how-to-protect-our-applications)  
2. SQL Injection | OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-community/attacks/SQL\_Injection](https://owasp.org/www-community/attacks/SQL_Injection)  
3. What is SQL Injection? \- Splunk, erişim tarihi Ağustos 11, 2025, [https://www.splunk.com/en\_us/blog/learn/sql-injection.html](https://www.splunk.com/en_us/blog/learn/sql-injection.html)  
4. What is SQL Injection (SQLi) and How to Prevent Attacks \- Acunetix, erişim tarihi Ağustos 11, 2025, [https://www.acunetix.com/websitesecurity/sql-injection/](https://www.acunetix.com/websitesecurity/sql-injection/)  
5. What is Blind SQL Injection? Tutorial & Examples | Web Security ..., erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/sql-injection/blind](https://portswigger.net/web-security/sql-injection/blind)  
6. SQL injection \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/learning-paths/sql-injection](https://portswigger.net/web-security/learning-paths/sql-injection)  
7. Testing for SQL injection vulnerabilities with Burp Suite \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/sql-injection/testing](https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/sql-injection/testing)  
8. What is NoSQL Injection? Exploitations and Security Tips \- Vaadata, erişim tarihi Ağustos 11, 2025, [https://www.vaadata.com/blog/what-is-nosql-injection-exploitations-and-security-best-practices/](https://www.vaadata.com/blog/what-is-nosql-injection-exploitations-and-security-best-practices/)  
9. NoSQL Injection Vulnerability | SecureFlag Security Knowledge Base, erişim tarihi Ağustos 11, 2025, [https://knowledge-base.secureflag.com/vulnerabilities/nosql\_injection/nosql\_injection\_vulnerability.html](https://knowledge-base.secureflag.com/vulnerabilities/nosql_injection/nosql_injection_vulnerability.html)  
10. NoSQL injection | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/nosql-injection](https://portswigger.net/web-security/nosql-injection)  
11. CAPEC-676: NoSQL Injection (Version 3.9) \- CAPEC, erişim tarihi Ağustos 11, 2025, [https://capec.mitre.org/data/definitions/676.html](https://capec.mitre.org/data/definitions/676.html)  
12. All labs | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/all-labs](https://portswigger.net/web-security/all-labs)  
13. Lab: Detecting NoSQL injection | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/nosql-injection/lab-nosql-injection-detection](https://portswigger.net/web-security/nosql-injection/lab-nosql-injection-detection)  
14. Command Injection | OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-community/attacks/Command\_Injection](https://owasp.org/www-community/attacks/Command_Injection)  
15. Command Injection: How it Works and 5 Ways to Protect Yourself \- Bright Security, erişim tarihi Ağustos 11, 2025, [https://brightsec.com/blog/os-command-injection/](https://brightsec.com/blog/os-command-injection/)  
16. OS command injection \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/kb/issues/00100100\_os-command-injection](https://portswigger.net/kb/issues/00100100_os-command-injection)  
17. What Is Command Injection? | Examples, Methods & Prevention \- Imperva, erişim tarihi Ağustos 11, 2025, [https://www.imperva.com/learn/application-security/command-injection/](https://www.imperva.com/learn/application-security/command-injection/)  
18. What is OS command injection, and how to prevent it? | Web ..., erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/os-command-injection](https://portswigger.net/web-security/os-command-injection)  
19. Testing for asynchronous OS command injection vulnerabilities with Burp Suite, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/command-injection/asynchronous](https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/command-injection/asynchronous)  
20. Command Injection Attacker \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/bappstore/33e4402eee514724b768c0342abadb8a](https://portswigger.net/bappstore/33e4402eee514724b768c0342abadb8a)  
21. Cross Site Scripting (XSS) | OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-community/attacks/xss/](https://owasp.org/www-community/attacks/xss/)  
22. Cross-site scripting \- Wikipedia, erişim tarihi Ağustos 11, 2025, [https://en.wikipedia.org/wiki/Cross-site\_scripting](https://en.wikipedia.org/wiki/Cross-site_scripting)  
23. Testing for Reflected Cross Site Scripting \- WSTG \- Latest | OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-project-web-security-testing-guide/latest/4-Web\_Application\_Security\_Testing/07-Input\_Validation\_Testing/01-Testing\_for\_Reflected\_Cross\_Site\_Scripting](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/01-Testing_for_Reflected_Cross_Site_Scripting)  
24. Cross-Site Scripting (XSS) & How to Prevent Attacks \- Splunk, erişim tarihi Ağustos 11, 2025, [https://www.splunk.com/en\_us/blog/learn/cross-site-scripting-xss-attacks.html](https://www.splunk.com/en_us/blog/learn/cross-site-scripting-xss-attacks.html)  
25. Testing for reflected XSS manually with Burp Suite \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/xss/testing-for-reflected-xss](https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/xss/testing-for-reflected-xss)  
26. Testing for blind XSS \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/xss/testing-for-blind-xss](https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/xss/testing-for-blind-xss)  
27. What is XXE (XML external entity) injection? Tutorial & Examples | Web Security Academy, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)  
28. What is XXE (XML External Entity) | Examples & Prevention \- Imperva, erişim tarihi Ağustos 11, 2025, [https://www.imperva.com/learn/application-security/xxe-xml-external-entity/](https://www.imperva.com/learn/application-security/xxe-xml-external-entity/)  
29. XML External Entities Injections (XXE) | Security \- Android Developers, erişim tarihi Ağustos 11, 2025, [https://developer.android.com/privacy-and-security/risks/xml-external-entities-injection](https://developer.android.com/privacy-and-security/risks/xml-external-entities-injection)  
30. XML External Entity (XXE) \- Invicti, erişim tarihi Ağustos 11, 2025, [https://www.invicti.com/learn/xml-external-entity-xxe/](https://www.invicti.com/learn/xml-external-entity-xxe/)  
31. Testing for XXE injection vulnerabilities with Burp Suite \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/xxe-injection/testing](https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/xxe-injection/testing)  
32. Lab: Exploiting XXE using external entities to retrieve files | Web Security Academy, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files](https://portswigger.net/web-security/xxe/lab-exploiting-xxe-to-retrieve-files)  
33. What is a blind XXE attack? Tutorial & Examples | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)  
34. XXE injection \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/xxe-injection](https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/xxe-injection)  
35. Server-side template injection | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/server-side-template-injection](https://portswigger.net/web-security/server-side-template-injection)  
36. What SSTI | Server-Side Template Injection Attacks \- Imperva, erişim tarihi Ağustos 11, 2025, [https://www.imperva.com/learn/application-security/server-side-template-injection-ssti/](https://www.imperva.com/learn/application-security/server-side-template-injection-ssti/)  
37. Authorization \- OWASP Cheat Sheet Series, erişim tarihi Ağustos 11, 2025, [https://cheatsheetseries.owasp.org/cheatsheets/Authorization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)  
38. A01 Broken Access Control \- OWASP Top 10:2021, erişim tarihi Ağustos 11, 2025, [https://owasp.org/Top10/A01\_2021-Broken\_Access\_Control/](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)  
39. Secure Coding Practices Checklist \- OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/stable-en/02-checklist/05-checklist](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/stable-en/02-checklist/05-checklist)  
40. A07 Identification and Authentication Failures \- OWASP Top 10:2021, erişim tarihi Ağustos 11, 2025, [https://owasp.org/Top10/A07\_2021-Identification\_and\_Authentication\_Failures/](https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/)  
41. Authentication \- OWASP Cheat Sheet Series, erişim tarihi Ağustos 11, 2025, [https://cheatsheetseries.owasp.org/cheatsheets/Authentication\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)  
42. Identification and Authentication Failures: OWASP Top 10 \#7 \- Vaadata, erişim tarihi Ağustos 11, 2025, [https://www.vaadata.com/blog/identification-and-authentication-failures-owasp-top-10-7/](https://www.vaadata.com/blog/identification-and-authentication-failures-owasp-top-10-7/)  
43. OWASP Top 10 \- Broken Access Control \- ProSec Networks, erişim tarihi Ağustos 11, 2025, [https://www.prosec-networks.com/en/blog/owasp-top-10-broken-access-control/](https://www.prosec-networks.com/en/blog/owasp-top-10-broken-access-control/)  
44. Broken Access Control in OWASP: What It Is & How to Prevent It? \- SiteLock, erişim tarihi Ağustos 11, 2025, [https://www.sitelock.com/blog/owasp-broken-access-control/](https://www.sitelock.com/blog/owasp-broken-access-control/)  
45. A5:2017-Broken Access Control \- OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-project-top-ten/2017/A5\_2017-Broken\_Access\_Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)  
46. Cross Site Request Forgery (CSRF) \- OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf)  
47. Testing for Cross Site Request Forgery (CSRF) \- WSTG \- Latest | OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-project-web-security-testing-guide/latest/4-Web\_Application\_Security\_Testing/06-Session\_Management\_Testing/05-Testing\_for\_Cross\_Site\_Request\_Forgery](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery)  
48. Cross-site request forgery \- Wikipedia, erişim tarihi Ağustos 11, 2025, [https://en.wikipedia.org/wiki/Cross-site\_request\_forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)  
49. Cross-Site Request Forgery (CSRF, XSRF): Definition, Examples & Prevention \- Rapid7, erişim tarihi Ağustos 11, 2025, [https://www.rapid7.com/fundamentals/cross-site-request-forgery/](https://www.rapid7.com/fundamentals/cross-site-request-forgery/)  
50. What is CSRF (Cross-site request forgery) Attacks, Mitigation, Prevention \- Acunetix, erişim tarihi Ağustos 11, 2025, [https://www.acunetix.com/websitesecurity/csrf-attacks/](https://www.acunetix.com/websitesecurity/csrf-attacks/)  
51. Bypassing CSRF token validation | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)  
52. Using Burp to Test for Cross-Site Request Forgery (CSRF) \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/support/using-burp-to-test-for-cross-site-request-forgery](https://portswigger.net/support/using-burp-to-test-for-cross-site-request-forgery)  
53. Lab: CSRF vulnerability with no defenses | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/csrf/lab-no-defenses](https://portswigger.net/web-security/csrf/lab-no-defenses)  
54. OAuth 2.0, erişim tarihi Ağustos 11, 2025, [https://oauth.net/2/](https://oauth.net/2/)  
55. OAuth 2.0 Security Best Practices for Developers \- DEV Community, erişim tarihi Ağustos 11, 2025, [https://dev.to/kimmaida/oauth-20-security-best-practices-for-developers-2ba5](https://dev.to/kimmaida/oauth-20-security-best-practices-for-developers-2ba5)  
56. RFC 9700 \- Best Current Practice for OAuth 2.0 Security, erişim tarihi Ağustos 11, 2025, [https://datatracker.ietf.org/doc/rfc9700/](https://datatracker.ietf.org/doc/rfc9700/)  
57. JWT attacks | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/jwt](https://portswigger.net/web-security/jwt)  
58. Cracking JWT Vulnerabilities \- Clear Gate, erişim tarihi Ağustos 11, 2025, [https://www.clear-gate.com/blog/cracking-jwt-vulnerabilities/](https://www.clear-gate.com/blog/cracking-jwt-vulnerabilities/)  
59. Algorithm confusion attacks | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/jwt/algorithm-confusion](https://portswigger.net/web-security/jwt/algorithm-confusion)  
60. What Is Server-Side Request Forgery ( SSRF)? \- F5, erişim tarihi Ağustos 11, 2025, [https://www.f5.com/glossary/ssrf](https://www.f5.com/glossary/ssrf)  
61. What is SSRF (Server-side request forgery)? Tutorial & Examples ..., erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/ssrf](https://portswigger.net/web-security/ssrf)  
62. Server-Side Request Forgery (SSRF) | Common Attacks & Risks \- Imperva, erişim tarihi Ağustos 11, 2025, [https://www.imperva.com/learn/application-security/server-side-request-forgery-ssrf/](https://www.imperva.com/learn/application-security/server-side-request-forgery-ssrf/)  
63. Server Side Request Forgery \- OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-community/attacks/Server\_Side\_Request\_Forgery](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)  
64. Blind SSRF vulnerabilities | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/ssrf/blind](https://portswigger.net/web-security/ssrf/blind)  
65. Testing for SSRF with Burp Suite \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/ssrf/testing-for-ssrf](https://portswigger.net/burp/documentation/desktop/testing-workflow/ssrf/testing-for-ssrf)  
66. Testing for blind SSRF with Burp Suite \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/ssrf/testing-for-blind-ssrf](https://portswigger.net/burp/documentation/desktop/testing-workflow/ssrf/testing-for-blind-ssrf)  
67. Testing for SSRF vulnerabilities with Burp Suite \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/ssrf](https://portswigger.net/burp/documentation/desktop/testing-workflow/ssrf)  
68. File path traversal \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/kb/issues/00100300\_file-path-traversal](https://portswigger.net/kb/issues/00100300_file-path-traversal)  
69. Path traversal | Security \- Android Developers, erişim tarihi Ağustos 11, 2025, [https://developer.android.com/privacy-and-security/risks/path-traversal](https://developer.android.com/privacy-and-security/risks/path-traversal)  
70. Path Traversal | OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-community/attacks/Path\_Traversal](https://owasp.org/www-community/attacks/Path_Traversal)  
71. What is Path Traversal? \- Checkmarx Application Security, erişim tarihi Ağustos 11, 2025, [https://checkmarx.com/glossary/path-traversal/](https://checkmarx.com/glossary/path-traversal/)  
72. What is path traversal, and how to prevent it? | Web Security Academy, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/file-path-traversal](https://portswigger.net/web-security/file-path-traversal)  
73. HTTP Host header attacks | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/host-header](https://portswigger.net/web-security/host-header)  
74. Demystifying Host Header Attacks: Understanding, Exploitation , & Resilient Defenses, erişim tarihi Ağustos 11, 2025, [https://www.appsecengineer.com/blog/demystifying-host-header-attacks-understanding-exploitation-resilient-defenses](https://www.appsecengineer.com/blog/demystifying-host-header-attacks-understanding-exploitation-resilient-defenses)  
75. What are HTTP host header attacks? \- Fastly, erişim tarihi Ağustos 11, 2025, [https://www.fastly.com/learning/security/what-are-http-host-header-attacks](https://www.fastly.com/learning/security/what-are-http-host-header-attacks)  
76. Host Header Inchecktion \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/bappstore/3908768b9ae945d8adf583052ad2e3b3](https://portswigger.net/bappstore/3908768b9ae945d8adf583052ad2e3b3)  
77. A Pentester's Guide to HTTP Request Smuggling | Cobalt, erişim tarihi Ağustos 11, 2025, [https://www.cobalt.io/blog/a-pentesters-guide-to-http-request-smuggling](https://www.cobalt.io/blog/a-pentesters-guide-to-http-request-smuggling)  
78. Lab: HTTP request smuggling, basic CL.TE vulnerability | Web Security Academy, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te](https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te)  
79. PortSwigger — Cross-origin resource sharing (CORS) | by Rza Shirinov | Jul, 2025 | Medium, erişim tarihi Ağustos 11, 2025, [https://medium.com/@rzashirinov38/portswigger-cross-origin-resource-sharing-cors-0b69134af002](https://medium.com/@rzashirinov38/portswigger-cross-origin-resource-sharing-cors-0b69134af002)  
80. What is CORS (cross-origin resource sharing)? Tutorial & Examples ..., erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)  
81. Cross-origin resource sharing: arbitrary origin trusted \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/kb/issues/00200601\_cross-origin-resource-sharing-arbitrary-origin-trusted](https://portswigger.net/kb/issues/00200601_cross-origin-resource-sharing-arbitrary-origin-trusted)  
82. Cross-origin resource sharing \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/kb/issues/00200600\_cross-origin-resource-sharing](https://portswigger.net/kb/issues/00200600_cross-origin-resource-sharing)  
83. Clickjacking | OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-community/attacks/Clickjacking](https://owasp.org/www-community/attacks/Clickjacking)  
84. Defend Against Clickjacking Attacks: Detection & Prevention \- Ping Identity, erişim tarihi Ağustos 11, 2025, [https://www.pingidentity.com/en/resources/cybersecurity-fundamentals/threats/clickjacking.html](https://www.pingidentity.com/en/resources/cybersecurity-fundamentals/threats/clickjacking.html)  
85. What is Clickjacking? \- Packetlabs, erişim tarihi Ağustos 11, 2025, [https://www.packetlabs.net/posts/what-is-clickjacking](https://www.packetlabs.net/posts/what-is-clickjacking)  
86. DOM-based vulnerabilities | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/dom-based](https://portswigger.net/web-security/dom-based)  
87. Testing for prototype pollution with DOM Invader \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/prototype-pollution](https://portswigger.net/burp/documentation/desktop/testing-workflow/input-validation/prototype-pollution)  
88. OWASP Top 10 Details About WebSocket Vulnerabilities and Mitigations \- SecureLayer7, erişim tarihi Ağustos 11, 2025, [https://blog.securelayer7.net/owasp-top-10-details-websocket-vulnerabilities-mitigations/](https://blog.securelayer7.net/owasp-top-10-details-websocket-vulnerabilities-mitigations/)  
89. OWASP Damn Vulnerable Web Sockets, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-project-damn-vulnerable-web-sockets/](https://owasp.org/www-project-damn-vulnerable-web-sockets/)  
90. How WebSockets Work? Vulnerabilities and Security Best Practices \- Vaadata, erişim tarihi Ağustos 11, 2025, [https://www.vaadata.com/blog/how-websockets-work-vulnerabilities-and-security-best-practices/](https://www.vaadata.com/blog/how-websockets-work-vulnerabilities-and-security-best-practices/)  
91. Testing for WebSockets security vulnerabilities | Web Security ..., erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/websockets](https://portswigger.net/web-security/websockets)  
92. WebSocket security: 9 common vulnerabilities & prevention methods \- DEV Community, erişim tarihi Ağustos 11, 2025, [https://dev.to/ably/websocket-security-9-common-vulnerabilities-prevention-methods-4kil](https://dev.to/ably/websocket-security-9-common-vulnerabilities-prevention-methods-4kil)  
93. Insecure deserialization | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/deserialization](https://portswigger.net/web-security/deserialization)  
94. Deserialization \- OWASP Cheat Sheet Series, erişim tarihi Ağustos 11, 2025, [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)  
95. Insecure Deserialization in Web Applications \- Invicti, erişim tarihi Ağustos 11, 2025, [https://www.invicti.com/blog/web-security/insecure-deserialization-in-web-applications/](https://www.invicti.com/blog/web-security/insecure-deserialization-in-web-applications/)  
96. Exploiting insecure deserialization vulnerabilities | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/deserialization/exploiting](https://portswigger.net/web-security/deserialization/exploiting)  
97. Lab: Modifying serialized data types | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-modifying-serialized-data-types)  
98. Web LLM attacks | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/llm-attacks](https://portswigger.net/web-security/llm-attacks)  
99. What are the OWASP Top 10 risks for LLMs? \- Cloudflare, erişim tarihi Ağustos 11, 2025, [https://www.cloudflare.com/learning/ai/owasp-top-10-risks-for-llms/](https://www.cloudflare.com/learning/ai/owasp-top-10-risks-for-llms/)  
100. OWASP Top 10 LLM, Updated 2025: Examples & Mitigation Strategies \- Oligo Security, erişim tarihi Ağustos 11, 2025, [https://www.oligo.security/academy/owasp-top-10-llm-updated-2025-examples-and-mitigation-strategies](https://www.oligo.security/academy/owasp-top-10-llm-updated-2025-examples-and-mitigation-strategies)  
101. How Bots Attack Large Language Models: The OWASP LLM Top 10 \- F5, erişim tarihi Ağustos 11, 2025, [https://www.f5.com/company/blog/how-bots-attack-large-language-models-the-owasp-llm-top-10](https://www.f5.com/company/blog/how-bots-attack-large-language-models-the-owasp-llm-top-10)  
102. Query Languages: A Simple Introduction \- Splunk, erişim tarihi Ağustos 11, 2025, [https://www.splunk.com/en\_us/blog/learn/query-languages.html](https://www.splunk.com/en_us/blog/learn/query-languages.html)  
103. Getting started with the GraphQL API \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/dast/user-guide/api-documentation/graphql-api/getting-started](https://portswigger.net/burp/documentation/dast/user-guide/api-documentation/graphql-api/getting-started)  
104. OWASP API Security Testing Framework | OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-project-api-security-testing-framework/](https://owasp.org/www-project-api-security-testing-framework/)  
105. API Security Testing in 2025 : Step by Step Guide \- TestingXperts, erişim tarihi Ağustos 11, 2025, [https://www.testingxperts.com/blog/api-security-testing](https://www.testingxperts.com/blog/api-security-testing)  
106. Web cache poisoning | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)  
107. Web Cache Entanglement: Novel Pathways to Poisoning \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/kb/papers/c3wwniai/web-cache-entanglement.pdf](https://portswigger.net/kb/papers/c3wwniai/web-cache-entanglement.pdf)  
108. Exploiting cache implementation flaws | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws)  
109. Web cache deception | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/web-cache-deception](https://portswigger.net/web-security/web-cache-deception)  
110. Cached and Confused: Web Cache Deception in the Wild \- USENIX, erişim tarihi Ağustos 11, 2025, [https://www.usenix.org/conference/usenixsecurity20/presentation/mirheidari](https://www.usenix.org/conference/usenixsecurity20/presentation/mirheidari)  
111. Web Cache Deception Escalates\! \- USENIX, erişim tarihi Ağustos 11, 2025, [https://www.usenix.org/system/files/sec22-mirheidari.pdf](https://www.usenix.org/system/files/sec22-mirheidari.pdf)  
112. Web Cache Deception | Invicti, erişim tarihi Ağustos 11, 2025, [https://www.invicti.com/web-vulnerability-scanner/vulnerabilities/web-cache-deception/](https://www.invicti.com/web-vulnerability-scanner/vulnerabilities/web-cache-deception/)  
113. Gotta Cache 'em all: bending the rules of web cache exploitation \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/kb/papers/kapvrid/gotta-cache-em-all.pdf](https://portswigger.net/kb/papers/kapvrid/gotta-cache-em-all.pdf)  
114. File uploads | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/file-upload](https://portswigger.net/web-security/file-upload)  
115. Unrestricted File Upload OWASP Challenge: Hands-On, Step-by-Step Walkthrough for Beginners | by Ends2Tech | Medium, erişim tarihi Ağustos 11, 2025, [https://medium.com/@Ends2Tech/unrestricted-file-upload-owasp-challenge-hands-on-step-by-step-walkthrough-for-beginners-90c5b39ab859](https://medium.com/@Ends2Tech/unrestricted-file-upload-owasp-challenge-hands-on-step-by-step-walkthrough-for-beginners-90c5b39ab859)  
116. Unrestricted File Upload \- OWASP Foundation, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-community/vulnerabilities/Unrestricted\_File\_Upload](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)  
117. Business logic vulnerabilities | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/logic-flaws](https://portswigger.net/web-security/logic-flaws)  
118. What Are Business Logic Vulnerabilities & 4 Ways to Prevent Them \- Pynt, erişim tarihi Ağustos 11, 2025, [https://www.pynt.io/learning-hub/owasp-top-10-guide/what-are-business-logic-vulnerabilities-4-ways-to-prevent-them](https://www.pynt.io/learning-hub/owasp-top-10-guide/what-are-business-logic-vulnerabilities-4-ways-to-prevent-them)  
119. OWASP Top 10 for Business Logic Abuse, erişim tarihi Ağustos 11, 2025, [https://owasp.org/www-project-top-10-for-business-logic-abuse/](https://owasp.org/www-project-top-10-for-business-logic-abuse/)  
120. Information disclosure vulnerabilities | Web Security Academy, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/information-disclosure](https://portswigger.net/web-security/information-disclosure)  
121. Sensitive Information Disclosure Vulnerability | SecureFlag Security Knowledge Base, erişim tarihi Ağustos 11, 2025, [https://knowledge-base.secureflag.com/vulnerabilities/sensitive\_information\_exposure/sensitive\_information\_disclosure\_vulnerability.html](https://knowledge-base.secureflag.com/vulnerabilities/sensitive_information_exposure/sensitive_information_disclosure_vulnerability.html)  
122. What is prototype pollution? | Web Security Academy \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/web-security/prototype-pollution](https://portswigger.net/web-security/prototype-pollution)  
123. Server-side prototype pollution: Black-box detection without the DoS \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/research/server-side-prototype-pollution](https://portswigger.net/research/server-side-prototype-pollution)  
124. Writing better searches with the Common Information Model \- Splunk Lantern, erişim tarihi Ağustos 11, 2025, [https://lantern.splunk.com/Splunk\_Platform/Product\_Tips/Data\_Management/Writing\_better\_searches\_with\_the\_Common\_Information\_Model](https://lantern.splunk.com/Splunk_Platform/Product_Tips/Data_Management/Writing_better_searches_with_the_Common_Information_Model)  
125. About data models \- Splunk Documentation, erişim tarihi Ağustos 11, 2025, [https://docs.splunk.com/Documentation/Splunk/9.4.2/Knowledge/Aboutdatamodels](https://docs.splunk.com/Documentation/Splunk/9.4.2/Knowledge/Aboutdatamodels)  
126. Solved: Searching The Web data using the Web data-model \- Splunk Community, erişim tarihi Ağustos 11, 2025, [https://community.splunk.com/t5/All-Apps-and-Add-ons/Searching-The-Web-data-using-the-Web-data-model/m-p/351130](https://community.splunk.com/t5/All-Apps-and-Add-ons/Searching-The-Web-data-using-the-Web-data-model/m-p/351130)  
127. Detection: SQL Injection with Long URLs \- Splunk Security Content, erişim tarihi Ağustos 11, 2025, [https://research.splunk.com/web/e0aad4cf-0790-423b-8328-7564d0d938f9/](https://research.splunk.com/web/e0aad4cf-0790-423b-8328-7564d0d938f9/)  
128. Detection: Windows Exchange Autodiscover SSRF Abuse | Splunk ..., erişim tarihi Ağustos 11, 2025, [https://research.splunk.com/web/d436f9e7-0ee7-4a47-864b-6dea2c4e2752/](https://research.splunk.com/web/d436f9e7-0ee7-4a47-864b-6dea2c4e2752/)  
129. Detection: Splunk CSRF in the SSG kvstore Client Endpoint, erişim tarihi Ağustos 11, 2025, [https://research.splunk.com/application/4742d5f7-ce00-45ce-9c79-5e98b43b4410/](https://research.splunk.com/application/4742d5f7-ce00-45ce-9c79-5e98b43b4410/)  
130. OWASP Top 10: Everything You Need to Know When Assessing ..., erişim tarihi Ağustos 11, 2025, [https://www.alooba.com/skills/concepts/information-security/owasp-top-10/](https://www.alooba.com/skills/concepts/information-security/owasp-top-10/)  
131. Everything You Need to Know When Assessing OWASP Skills \- Alooba, erişim tarihi Ağustos 11, 2025, [https://www.alooba.com/skills/concepts/information-security/owasp/](https://www.alooba.com/skills/concepts/information-security/owasp/)  
132. Application Security Engineer: Roles, Skills & Career Path ..., erişim tarihi Ağustos 11, 2025, [https://www.hackerone.com/knowledge-center/application-security-engineer](https://www.hackerone.com/knowledge-center/application-security-engineer)  
133. Cyber Security Skills Roadmap \- SANS Institute, erişim tarihi Ağustos 11, 2025, [https://www.sans.org/cyber-security-skills-roadmap](https://www.sans.org/cyber-security-skills-roadmap)  
134. Essential Cybersecurity Skills for 2025 \- uCertify, erişim tarihi Ağustos 11, 2025, [https://cenitcollege.ucertify.com/blog/essential-cybersecurity-skills/](https://cenitcollege.ucertify.com/blog/essential-cybersecurity-skills/)  
135. How to Use OWASP Guidelines for Web Security, erişim tarihi Ağustos 11, 2025, [https://blog.pixelfreestudio.com/how-to-use-owasp-guidelines-for-web-security/](https://blog.pixelfreestudio.com/how-to-use-owasp-guidelines-for-web-security/)  
136. Working with JWTs in Burp Suite \- PortSwigger, erişim tarihi Ağustos 11, 2025, [https://portswigger.net/burp/documentation/desktop/testing-workflow/session-management/jwts](https://portswigger.net/burp/documentation/desktop/testing-workflow/session-management/jwts)  
137. Detection: Detect Webshell Exploit Behavior | Splunk Security Content, erişim tarihi Ağustos 11, 2025, [https://research.splunk.com/endpoint/22597426-6dbd-49bd-bcdc-4ec19857192f/](https://research.splunk.com/endpoint/22597426-6dbd-49bd-bcdc-4ec19857192f/)  
138. Detection: Splunk Path Traversal In Splunk App For Lookup File Edit ..., erişim tarihi Ağustos 11, 2025, [https://research.splunk.com/application/8ed58987-738d-4917-9e44-b8ef6ab948a6/](https://research.splunk.com/application/8ed58987-738d-4917-9e44-b8ef6ab948a6/)  
139. erişim tarihi Ocak 1, 1970, [https://letsdefend.io/blog/detecting-xml-external-entity-xxe-attack/](https://letsdefend.io/blog/detecting-xml-external-entity-xxe-attack/)  
140. What is OWASP? What is the OWASP Top 10? | Cloudflare, erişim tarihi Ağustos 11, 2025, [https://www.cloudflare.com/learning/security/threats/owasp-top-10/](https://www.cloudflare.com/learning/security/threats/owasp-top-10/)  
141. What skills do you believe will be essential for professionals in cybersecurity to thrive in the coming decade? \- Quora, erişim tarihi Ağustos 11, 2025, [https://www.quora.com/What-skills-do-you-believe-will-be-essential-for-professionals-in-cybersecurity-to-thrive-in-the-coming-decade](https://www.quora.com/What-skills-do-you-believe-will-be-essential-for-professionals-in-cybersecurity-to-thrive-in-the-coming-decade)
